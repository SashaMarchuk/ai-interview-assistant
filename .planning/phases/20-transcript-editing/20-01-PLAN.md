---
phase: 20-transcript-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/transcript.ts
  - entrypoints/content.tsx
  - src/hooks/useCaptureMode.ts
autonomous: true

must_haves:
  truths:
    - "Edited transcript text is used in LLM requests instead of original transcription"
    - "Soft-deleted transcript entries are excluded from LLM context"
    - "Content script receives edit/delete/undo events and updates its overlay map"
    - "Capture hotkey does not fire when user is typing in an input field"
  artifacts:
    - path: "src/types/transcript.ts"
      provides: "TranscriptEdit interface"
      contains: "TranscriptEdit"
    - path: "entrypoints/content.tsx"
      provides: "Edit overlay map, applyEdits function, custom event listeners"
      contains: "transcriptEdits"
    - path: "src/hooks/useCaptureMode.ts"
      provides: "Input element guard on hotkey handler"
      contains: "tagName"
  key_links:
    - from: "entrypoints/content.tsx"
      to: "src/types/transcript.ts"
      via: "import TranscriptEdit"
      pattern: "import.*TranscriptEdit"
    - from: "entrypoints/content.tsx applyEdits"
      to: "entrypoints/content.tsx getFullTranscript/getRecentTranscript"
      via: "applyEdits called inside transcript getter functions"
      pattern: "applyEdits\\(currentTranscript"
    - from: "entrypoints/content.tsx dispatchTranscriptUpdate"
      to: "entrypoints/content.tsx applyEdits"
      via: "edits applied before dispatching to overlay"
      pattern: "applyEdits.*entries"
---

<objective>
Build the transcript editing data layer: type definitions, edit overlay map in content.tsx, custom event listeners for edit/delete/undo, and hotkey guard for input elements.

Purpose: Establish the data backbone that transforms raw transcript entries using an edit overlay map. This enables the UI (Plan 02) to dispatch edit events and have them reflected in both the overlay display and LLM context. Also prevents the capture hotkey from interfering when the user is typing in an edit input.

Output: TranscriptEdit type, content.tsx with edit map + applyEdits + event listeners, useCaptureMode with input guard.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-transcript-editing/20-RESEARCH.md
@src/types/transcript.ts
@entrypoints/content.tsx
@src/hooks/useCaptureMode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TranscriptEdit type and wire edit overlay map in content.tsx</name>
  <files>src/types/transcript.ts, entrypoints/content.tsx</files>
  <action>
**1. Add TranscriptEdit interface to src/types/transcript.ts:**

Add at the end of the file (after the existing types), a new export:

```typescript
/**
 * Edit overlay for a transcript entry.
 * Stored separately from the original entry to preserve undo capability.
 * Session-scoped: resets on page reload (matches interview session lifecycle).
 */
export interface TranscriptEdit {
  /** The user-corrected text (null if only soft-deleted, not text-edited) */
  editedText: string | null;
  /** Whether this entry is hidden from view and LLM context */
  isDeleted: boolean;
  /** Original text preserved for undo (copied at edit time) */
  originalText: string;
}
```

**2. Add edit overlay map and applyEdits function to entrypoints/content.tsx:**

After the `let currentTranscript: TranscriptEntry[] = [];` line (~line 60), add:

```typescript
import type { TranscriptEdit } from '../src/types/transcript';

// Edit overlay map: session-scoped edits layered on top of raw transcript
const transcriptEdits = new Map<string, TranscriptEdit>();
```

Note: The import must be added at the top of the file with the other imports. The Map declaration goes near `currentTranscript`.

Add the `applyEdits` function before `formatEntries`:

```typescript
/**
 * Apply edit overlay to raw transcript entries.
 * Filters out soft-deleted entries and replaces text for edited entries.
 * Creates new objects (spread) so React.memo detects changes.
 */
function applyEdits(entries: TranscriptEntry[]): TranscriptEntry[] {
  return entries.reduce<TranscriptEntry[]>((acc, entry) => {
    const edit = transcriptEdits.get(entry.id);
    if (edit?.isDeleted) return acc; // Skip soft-deleted
    if (edit?.editedText != null) {
      acc.push({ ...entry, text: edit.editedText });
    } else {
      acc.push(entry);
    }
    return acc;
  }, []);
}
```

**3. Modify getRecentTranscript, getFullTranscript, getTranscriptSince to use applyEdits:**

Change the three functions:

```typescript
function getTranscriptSince(timestamp: number): string {
  return formatEntries(applyEdits(currentTranscript).filter((e) => e.isFinal && e.timestamp >= timestamp));
}

function getRecentTranscript(): string {
  return formatEntries(applyEdits(currentTranscript).filter((e) => e.isFinal).slice(-5));
}

function getFullTranscript(): string {
  return formatEntries(applyEdits(currentTranscript).filter((e) => e.isFinal));
}
```

The key change: wrap `currentTranscript` with `applyEdits()` in all three functions.

**4. Modify dispatchTranscriptUpdate to apply edits before dispatching to overlay:**

```typescript
function dispatchTranscriptUpdate(entries: TranscriptEntry[]): void {
  currentTranscript = entries; // Keep raw for undo reference
  const displayEntries = applyEdits(entries);
  window.dispatchEvent(
    new CustomEvent<TranscriptUpdateEventDetail>('transcript-update', {
      detail: { entries: displayEntries },
    }),
  );
}
```

The raw entries are stored in `currentTranscript` (needed for undo original text lookup). The overlay receives the edited/filtered version.

**5. Add custom event listeners for edit/delete/undo in content.tsx:**

Add a function `setupTranscriptEditListeners()` and call it during content script initialization (e.g., inside the main `export default defineContentScript` block, near where other event listeners are set up). The listeners should be added to `window`:

```typescript
/**
 * Set up listeners for transcript edit events from the overlay.
 * The overlay dispatches these events; content.tsx applies them to the edit map
 * and re-dispatches the transformed transcript.
 */
function setupTranscriptEditListeners(): void {
  window.addEventListener('transcript-edit', ((e: CustomEvent<{ id: string; editedText: string }>) => {
    const { id, editedText } = e.detail;
    const entry = currentTranscript.find((t) => t.id === id);
    if (!entry) return;

    const existing = transcriptEdits.get(id);
    transcriptEdits.set(id, {
      editedText,
      isDeleted: existing?.isDeleted ?? false,
      originalText: existing?.originalText ?? entry.text,
    });
    // Re-dispatch with edits applied
    dispatchTranscriptUpdate(currentTranscript);
  }) as EventListener);

  window.addEventListener('transcript-delete', ((e: CustomEvent<{ id: string }>) => {
    const { id } = e.detail;
    const entry = currentTranscript.find((t) => t.id === id);
    if (!entry) return;

    const existing = transcriptEdits.get(id);
    transcriptEdits.set(id, {
      editedText: existing?.editedText ?? null,
      isDeleted: true,
      originalText: existing?.originalText ?? entry.text,
    });
    dispatchTranscriptUpdate(currentTranscript);
  }) as EventListener);

  window.addEventListener('transcript-undo', ((e: CustomEvent<{ id: string }>) => {
    const { id } = e.detail;
    transcriptEdits.delete(id);
    dispatchTranscriptUpdate(currentTranscript);
  }) as EventListener);
}
```

Call `setupTranscriptEditListeners()` once during content script initialization. Find the appropriate location -- likely near the existing event listener setup in `defineContentScript`, before or after the `chrome.runtime.onMessage` listener registration. It should be called once when the content script first loads.

**Important:** The `TranscriptEdit` import path from content.tsx (which is in `entrypoints/`) to types must use the correct relative path: `'../src/types/transcript'`. Check existing imports in the file for the established pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. There should be zero TypeScript errors. Verify:
1. TranscriptEdit is exported from src/types/transcript.ts
2. transcriptEdits Map is declared in content.tsx
3. applyEdits function is defined and called in getRecentTranscript, getFullTranscript, getTranscriptSince
4. dispatchTranscriptUpdate applies edits before dispatching
5. Three event listeners (transcript-edit, transcript-delete, transcript-undo) are registered
  </verify>
  <done>
TranscriptEdit type is defined. Edit overlay map exists in content.tsx. All three transcript getter functions (getTranscriptSince, getRecentTranscript, getFullTranscript) apply edits before formatting. dispatchTranscriptUpdate sends edited entries to the overlay. Three custom event listeners handle edit/delete/undo operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add input element guard to useCaptureMode hotkey handler</name>
  <files>src/hooks/useCaptureMode.ts</files>
  <action>
In `src/hooks/useCaptureMode.ts`, modify the `handleKeyDown` callback to skip hotkey processing when the user is typing in an input or textarea. This prevents the capture hotkey (e.g., Space) from triggering capture mode while editing a transcript entry.

Add the guard at the very beginning of the `handleKeyDown` callback, BEFORE the `matchesHotkey` check:

```typescript
const handleKeyDown = useCallback(
  (e: KeyboardEvent) => {
    // Skip capture hotkey when user is typing in an input/textarea
    // Uses e.target (not document.activeElement) because Shadow DOM boundary
    // makes activeElement unreliable
    const target = e.target as HTMLElement;
    if (
      target.tagName === 'INPUT' ||
      target.tagName === 'TEXTAREA' ||
      target.isContentEditable
    ) {
      return;
    }

    if (!matchesHotkey(e, parsedHotkey)) return;
    // ... rest unchanged
  },
  [parsedHotkey, onCapture, captureMode, getTranscriptSince],
);
```

**Why `e.target` not `document.activeElement`:** The overlay runs inside Shadow DOM. `document.activeElement` from the main page context sees the shadow host element, not the actual focused input inside the shadow tree. `e.target` in the event gives us the actual element that received the keypress, even across shadow boundaries (because event listeners are registered inside the shadow root via React).

**Do NOT change the `handleKeyUp` handler.** If `handleKeyDown` returns early (skips), no `isHoldingRef` is set, so `handleKeyUp` will naturally return early at the `!isHoldingRef.current` check.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Verify the guard is the first check in handleKeyDown, before `matchesHotkey`. Confirm handleKeyUp is unchanged.
  </verify>
  <done>
Pressing the capture hotkey (e.g., Space) while focused on an input or textarea element does not trigger capture mode. The guard checks e.target.tagName for INPUT/TEXTAREA/contentEditable and returns early.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint entrypoints/content.tsx src/types/transcript.ts src/hooks/useCaptureMode.ts` passes
3. TranscriptEdit interface is properly exported
4. applyEdits is used in all three transcript getter functions AND in dispatchTranscriptUpdate
5. Three event listeners (transcript-edit, transcript-delete, transcript-undo) are registered
6. useCaptureMode guards against input/textarea elements
</verification>

<success_criteria>
- TranscriptEdit type is defined and exported from src/types/transcript.ts
- content.tsx has a Map-based edit overlay that transforms entries at read time
- getFullTranscript(), getRecentTranscript(), and getTranscriptSince() all apply edits (EDIT-03 data layer)
- dispatchTranscriptUpdate sends edited entries to overlay (not raw entries)
- Custom event listeners for edit/delete/undo are registered and functional
- Capture hotkey is suppressed when typing in input fields
- All TypeScript and ESLint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-transcript-editing/20-01-SUMMARY.md`
</output>
