---
phase: 20-transcript-editing
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/overlay/TranscriptPanel.tsx
  - src/overlay/hooks/useAutoScroll.ts
autonomous: true

must_haves:
  truths:
    - "Double-clicking a transcript entry enables inline editing with a text input"
    - "Pressing Enter saves the edit and Escape cancels it"
    - "User can soft-delete a transcript entry and it disappears from the list"
    - "User can undo any edit or soft-delete to restore the original transcript text"
    - "Edited entries show a visual indicator and the original text on hover"
    - "Auto-scroll is suppressed while editing an entry"
  artifacts:
    - path: "src/overlay/TranscriptPanel.tsx"
      provides: "Inline edit UI, delete button, undo button, editing state management"
      contains: "editingId"
    - path: "src/overlay/hooks/useAutoScroll.ts"
      provides: "Edit-aware auto-scroll suppression"
      contains: "isEditing"
  key_links:
    - from: "src/overlay/TranscriptPanel.tsx dispatchEditEvent"
      to: "entrypoints/content.tsx transcript-edit listener"
      via: "CustomEvent('transcript-edit')"
      pattern: "transcript-edit"
    - from: "src/overlay/TranscriptPanel.tsx dispatchDeleteEvent"
      to: "entrypoints/content.tsx transcript-delete listener"
      via: "CustomEvent('transcript-delete')"
      pattern: "transcript-delete"
    - from: "src/overlay/TranscriptPanel.tsx dispatchUndoEvent"
      to: "entrypoints/content.tsx transcript-undo listener"
      via: "CustomEvent('transcript-undo')"
      pattern: "transcript-undo"
---

<objective>
Build the transcript editing UI in TranscriptPanel: inline edit mode on double-click, soft-delete button, undo button, visual indicators for edited entries, and auto-scroll suppression during editing.

Purpose: Provide users with direct manipulation of transcript entries so they can correct STT errors, hide irrelevant entries, and restore originals -- completing all four EDIT requirements (EDIT-01 through EDIT-04).

Output: Updated TranscriptPanel.tsx with full editing UI and updated useAutoScroll with edit-aware suppression.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-transcript-editing/20-RESEARCH.md
@.planning/phases/20-transcript-editing/20-01-SUMMARY.md
@src/overlay/TranscriptPanel.tsx
@src/overlay/hooks/useAutoScroll.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit-aware auto-scroll suppression to useAutoScroll</name>
  <files>src/overlay/hooks/useAutoScroll.ts</files>
  <action>
Modify `useAutoScroll` to accept a second parameter `isEditing` (boolean, default false). When `isEditing` is true, skip the scroll-to-bottom effect. This prevents the edit input from scrolling out of view when new transcript entries arrive during editing.

Update the hook signature and effect:

```typescript
export function useAutoScroll<T>(dependency: T, isEditing: boolean = false) {
  const bottomRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // Suppress auto-scroll when user is editing a transcript entry
    // to prevent the edit input from jumping out of view
    if (isEditing) return;

    bottomRef.current?.scrollIntoView({
      behavior: 'smooth',
      block: 'end',
      inline: 'nearest',
    });
  }, [dependency, isEditing]);

  return bottomRef;
}
```

This is a backward-compatible change: all existing callers pass only `dependency`, so `isEditing` defaults to `false` and behavior is unchanged.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Confirm the hook accepts two parameters and the default is false.
  </verify>
  <done>
useAutoScroll accepts an optional `isEditing` parameter. When true, auto-scroll is suppressed. Existing callers are unaffected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build inline editing UI in TranscriptPanel</name>
  <files>src/overlay/TranscriptPanel.tsx</files>
  <action>
Rewrite the `TranscriptPanel` and `TranscriptEntryRow` components to support inline editing, soft-delete, and undo. The panel is 340px wide (min 280px), entries are text-sm (14px), so controls must be compact.

**1. Add editing state to TranscriptPanel:**

```typescript
const [editingId, setEditingId] = useState<string | null>(null);
const [editText, setEditText] = useState('');
```

Pass `isEditing: editingId !== null` to `useAutoScroll`:
```typescript
const bottomRef = useAutoScroll(entries.length, editingId !== null);
```

**2. Add event dispatch helper functions (module-level, outside components):**

```typescript
function dispatchEditEvent(id: string, editedText: string): void {
  window.dispatchEvent(
    new CustomEvent('transcript-edit', { detail: { id, editedText } }),
  );
}

function dispatchDeleteEvent(id: string): void {
  window.dispatchEvent(
    new CustomEvent('transcript-delete', { detail: { id } }),
  );
}

function dispatchUndoEvent(id: string): void {
  window.dispatchEvent(
    new CustomEvent('transcript-undo', { detail: { id } }),
  );
}
```

**3. Enhance TranscriptPanel props to include edit info:**

The TranscriptPanel needs to know which entries have been edited/deleted (for undo buttons on non-visible entries). However, since edits are tracked in content.tsx and the overlay only sees the filtered entries, the overlay needs a separate signal.

**Approach:** Add an `editedIds` set to TranscriptPanel props. This set is maintained by the content script and passed via the custom event detail. Alternatively (simpler), track edited state directly in the overlay by listening for a separate event.

**Simpler approach chosen:** The TranscriptPanel will not track which entries are edited -- it will just show the current state. The "edited" indicator and undo button are rendered per-entry based on an `isEdited` property that the content script adds to the entry detail when dispatching.

**Actually simplest approach:** Add an optional `isEdited` flag to entries dispatched to the overlay. In content.tsx dispatchTranscriptUpdate, after applying edits, mark entries that have been edited:

This requires a minor addition to content.tsx (from Plan 01): when building displayEntries, add an `isEdited` boolean. Since we cannot modify TranscriptEntry interface (it's the wire format), we'll use a local extended type in TranscriptPanel.

**Final approach -- extend event detail:** The content.tsx `dispatchTranscriptUpdate` already applies edits. We will extend it to also include a `Set<string>` of edited IDs in the event detail. The TranscriptPanel reads this set from the event.

**Simplest implementation:** Just pass editedIds as part of the transcript-update event detail. This requires a small change to content.tsx (add `editedIds: string[]` to TranscriptUpdateEventDetail).

In `entrypoints/content.tsx`, modify the `TranscriptUpdateEventDetail` type (or its local equivalent) and `dispatchTranscriptUpdate`:

```typescript
// Add to the event detail
interface TranscriptUpdateEventDetail {
  entries: TranscriptEntry[];
  editedIds: string[];  // IDs of entries that have been edited (for UI indicators)
}

// In dispatchTranscriptUpdate, include editedIds:
function dispatchTranscriptUpdate(entries: TranscriptEntry[]): void {
  currentTranscript = entries;
  const displayEntries = applyEdits(entries);
  const editedIds = Array.from(transcriptEdits.keys());
  window.dispatchEvent(
    new CustomEvent<TranscriptUpdateEventDetail>('transcript-update', {
      detail: { entries: displayEntries, editedIds },
    }),
  );
}
```

Then in `Overlay.tsx` (or wherever `transcript-update` is listened to), pass `editedIds` through to TranscriptPanel. Read the Overlay.tsx to find how transcript state flows.

**However**, to keep this plan focused on TranscriptPanel.tsx and avoid modifying too many files, use a **self-contained approach**: TranscriptPanel maintains its own `editedIds` set by listening for `transcript-edit`, `transcript-delete`, `transcript-undo` events directly. This is slightly redundant with content.tsx but keeps the UI component self-contained:

```typescript
// Inside TranscriptPanel component:
const [editedIds, setEditedIds] = useState<Set<string>>(new Set());

useEffect(() => {
  const handleEdit = ((e: CustomEvent<{ id: string }>) => {
    setEditedIds(prev => new Set(prev).add(e.detail.id));
  }) as EventListener;

  const handleDelete = ((e: CustomEvent<{ id: string }>) => {
    setEditedIds(prev => new Set(prev).add(e.detail.id));
  }) as EventListener;

  const handleUndo = ((e: CustomEvent<{ id: string }>) => {
    setEditedIds(prev => {
      const next = new Set(prev);
      next.delete(e.detail.id);
      return next;
    });
  }) as EventListener;

  window.addEventListener('transcript-edit', handleEdit);
  window.addEventListener('transcript-delete', handleDelete);
  window.addEventListener('transcript-undo', handleUndo);
  return () => {
    window.removeEventListener('transcript-edit', handleEdit);
    window.removeEventListener('transcript-delete', handleDelete);
    window.removeEventListener('transcript-undo', handleUndo);
  };
}, []);
```

**Wait -- this has a flaw.** TranscriptPanel only receives the filtered entries (soft-deleted are gone). So it can't show undo for deleted entries.

**Resolution:** For soft-deleted entries, we need a separate "undo bar" that shows deleted entries. The simplest UX: when a user deletes an entry, show a small "Undo" toast/bar at the bottom of the transcript panel with the entry text, which disappears after the next entry arrives or after 5 seconds.

**Actually, re-reading the requirement:** "User can undo any edit or soft-delete to restore the original transcript text." The user needs a way to undo soft-deletes too. The simplest approach:

**Approach: Show deleted entries as collapsed/greyed with undo button.**

Instead of fully filtering deleted entries from the UI, show them as a minimal "deleted" indicator row with an undo button. They're already excluded from LLM context (applyEdits in content.tsx handles that). The UI just shows them differently.

This means we need to modify content.tsx's `dispatchTranscriptUpdate` slightly: **do NOT filter deleted entries from the display entries**. Instead, mark them. The LLM context functions (getFullTranscript, etc.) still filter them. Only the display keeps them visible (but styled as deleted).

**Revised dispatchTranscriptUpdate in content.tsx (this task will make a small addition to content.tsx):**

```typescript
function dispatchTranscriptUpdate(entries: TranscriptEntry[]): void {
  currentTranscript = entries;
  // For display: apply text edits but keep deleted entries (marked for UI rendering)
  const displayEntries = entries.map(entry => {
    const edit = transcriptEdits.get(entry.id);
    if (edit?.editedText != null) {
      return { ...entry, text: edit.editedText };
    }
    return entry;
  });
  const editedIds = Array.from(transcriptEdits.keys());
  const deletedIds = Array.from(transcriptEdits.entries())
    .filter(([, edit]) => edit.isDeleted)
    .map(([id]) => id);
  window.dispatchEvent(
    new CustomEvent('transcript-update', {
      detail: { entries: displayEntries, editedIds, deletedIds },
    }),
  );
}
```

**Note:** The `applyEdits` function in content.tsx from Plan 01 is ONLY used by getFullTranscript/getRecentTranscript/getTranscriptSince for LLM context. The display pipeline uses a separate transform that keeps deleted entries visible but marked.

**4. Update TranscriptPanel props:**

```typescript
interface TranscriptPanelProps {
  entries: TranscriptEntryType[];
  editedIds?: string[];   // IDs of entries with edits applied
  deletedIds?: string[];  // IDs of soft-deleted entries
}
```

Update the parent component (Overlay.tsx) to pass these through from the event detail.

**5. Modify TranscriptEntryRow to support three modes:**

a) **Normal mode** (default): Shows entry as today (speaker, time, text). On hover, show a small delete (X) button.

b) **Editing mode** (`editingId === entry.id`): Replace text span with a controlled `<input>` element. Input is `text-sm`, full width, with dark background to match overlay. Auto-focused via `autoFocus` attribute. `onKeyDown`: Enter saves, Escape cancels. `onBlur`: save (same as Enter).

c) **Deleted mode** (`deletedIds.includes(entry.id)`): Show a compact greyed-out row: "~~[speaker text]~~" with an undo button. Text is `line-through opacity-40`. Only the undo button is interactive.

d) **Edited indicator**: If entry.id is in editedIds (and not deleted), show a small "(edited)" text in muted color after the text. Add `title` attribute with original text (from a tooltip showing what it was before editing). For the original text, the undo event will restore it -- the tooltip is a nice-to-have; we can skip it since the overlay doesn't have the original text. Instead just show "(edited)" label.

**6. Double-click handler:**

```typescript
const handleDoubleClick = useCallback((entry: TranscriptEntryType) => {
  if (deletedIds?.includes(entry.id)) return; // Can't edit deleted entries
  setEditingId(entry.id);
  setEditText(entry.text);
}, [deletedIds]);
```

**7. Save and cancel handlers:**

```typescript
const handleSave = useCallback((entryId: string) => {
  if (editText.trim()) {
    dispatchEditEvent(entryId, editText.trim());
  }
  setEditingId(null);
}, [editText]);

const handleCancel = useCallback(() => {
  setEditingId(null);
}, []);
```

**8. Key handler for edit input:**

```typescript
const handleEditKeyDown = useCallback((e: React.KeyboardEvent, entryId: string) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    handleSave(entryId);
  } else if (e.key === 'Escape') {
    e.preventDefault();
    handleCancel();
  }
}, [handleSave, handleCancel]);
```

**9. Update TranscriptEntryRow to accept new props:**

The memo'd TranscriptEntryRow needs additional props: `isEditing`, `isDeleted`, `isEdited`, `editText`, `onDoubleClick`, `onEditChange`, `onEditKeyDown`, `onEditBlur`, `onDelete`, `onUndo`.

To keep the component clean, create the entry row inline or pass callbacks. Given the small component size, converting TranscriptEntryRow from memo'd component to inline rendering within the map is acceptable -- OR keep memo but add the necessary props.

**Recommended: Keep memo, add props.** The memo comparison will use the new props, which is correct.

```typescript
interface TranscriptEntryRowProps {
  entry: TranscriptEntryType;
  isEditing: boolean;
  isDeleted: boolean;
  isEdited: boolean;
  editText: string;
  onDoubleClick: () => void;
  onEditChange: (text: string) => void;
  onEditKeyDown: (e: React.KeyboardEvent) => void;
  onEditBlur: () => void;
  onDelete: () => void;
  onUndo: () => void;
}
```

**10. Render logic inside TranscriptEntryRow:**

```tsx
// If deleted: show compact deleted row
if (isDeleted) {
  return (
    <div className="mb-1 flex items-center justify-between text-sm opacity-40">
      <span className="line-through truncate">
        <span className={`font-medium ${speakerColor}`}>{entry.speaker}</span>
        <span className="ml-1">{entry.text}</span>
      </span>
      <button
        onClick={onUndo}
        className="ml-1 flex-shrink-0 text-xs text-yellow-400 hover:text-yellow-300"
        title="Undo delete"
      >
        undo
      </button>
    </div>
  );
}

// If editing: show input
if (isEditing) {
  return (
    <div className="mb-1.5 text-sm">
      <span className={`font-medium ${speakerColor}`}>{entry.speaker}</span>
      <span className="ml-1 text-xs text-white/40">({formattedTime})</span>
      <input
        type="text"
        value={editText}
        onChange={(e) => onEditChange(e.target.value)}
        onKeyDown={onEditKeyDown}
        onBlur={onEditBlur}
        autoFocus
        className="ml-1 w-full rounded border border-white/20 bg-white/10 px-1 py-0.5 text-sm text-white/90 outline-none focus:border-blue-400"
      />
    </div>
  );
}

// Normal mode: show text with hover controls
return (
  <div
    className={`group mb-1.5 text-sm last:mb-0 ${!entry.isFinal ? 'italic opacity-60' : ''}`}
    onDoubleClick={onDoubleClick}
  >
    <span className={`font-medium ${speakerColor}`}>{entry.speaker}</span>
    <span className="ml-1 text-xs text-white/40">({formattedTime})</span>
    <span className="ml-1 text-white/90">
      {entry.text}
      {!entry.isFinal && <span className="text-white/40">...</span>}
    </span>
    {isEdited && (
      <span className="ml-1 text-xs text-yellow-400/60">(edited)</span>
    )}
    {/* Hover controls: delete and undo (if edited) */}
    <span className="ml-1 hidden group-hover:inline-flex gap-1">
      {isEdited && (
        <button
          onClick={onUndo}
          className="text-xs text-yellow-400 hover:text-yellow-300"
          title="Undo edit"
        >
          undo
        </button>
      )}
      <button
        onClick={onDelete}
        className="text-xs text-red-400 hover:text-red-300"
        title="Hide from transcript"
      >
        x
      </button>
    </span>
  </div>
);
```

**11. Wire TranscriptPanel map to pass new props:**

```tsx
{entries.map((entry) => (
  <TranscriptEntryRow
    key={entry.id}
    entry={entry}
    isEditing={editingId === entry.id}
    isDeleted={deletedIds?.includes(entry.id) ?? false}
    isEdited={editedIds?.includes(entry.id) ?? false}
    editText={editingId === entry.id ? editText : ''}
    onDoubleClick={() => handleDoubleClick(entry)}
    onEditChange={setEditText}
    onEditKeyDown={(e) => handleEditKeyDown(e, entry.id)}
    onEditBlur={() => handleSave(entry.id)}
    onDelete={() => dispatchDeleteEvent(entry.id)}
    onUndo={() => dispatchUndoEvent(entry.id)}
  />
))}
```

**12. Update content.tsx dispatchTranscriptUpdate (small change from Plan 01):**

In `entrypoints/content.tsx`, modify `dispatchTranscriptUpdate` so the display entries include ALL entries (not just non-deleted), but text edits are applied. Add `editedIds` and `deletedIds` arrays to the event detail. The `applyEdits` function is used ONLY by getFullTranscript/getRecentTranscript/getTranscriptSince.

This means Plan 01's `dispatchTranscriptUpdate` needs a small adjustment. If Plan 01 was already executed, modify it:

```typescript
function dispatchTranscriptUpdate(entries: TranscriptEntry[]): void {
  currentTranscript = entries;
  // Display entries: apply text edits but keep deleted entries visible for undo UI
  const displayEntries = entries.map((entry) => {
    const edit = transcriptEdits.get(entry.id);
    if (edit?.editedText != null) {
      return { ...entry, text: edit.editedText };
    }
    return entry;
  });
  const editedIds = Array.from(transcriptEdits.keys());
  const deletedIds: string[] = [];
  transcriptEdits.forEach((edit, id) => {
    if (edit.isDeleted) deletedIds.push(id);
  });
  window.dispatchEvent(
    new CustomEvent('transcript-update', {
      detail: { entries: displayEntries, editedIds, deletedIds },
    }),
  );
}
```

**13. Update Overlay.tsx to pass editedIds/deletedIds to TranscriptPanel:**

Find where `Overlay.tsx` listens for `transcript-update` and passes entries to `TranscriptPanel`. Add `editedIds` and `deletedIds` state and pass them through:

```typescript
const [editedIds, setEditedIds] = useState<string[]>([]);
const [deletedIds, setDeletedIds] = useState<string[]>([]);

// In the transcript-update listener:
setEditedIds(detail.editedIds ?? []);
setDeletedIds(detail.deletedIds ?? []);

// In JSX:
<TranscriptPanel entries={transcript} editedIds={editedIds} deletedIds={deletedIds} />
```

**14. Add useState import to TranscriptPanel.tsx** (it currently only imports memo and useMemo):

```typescript
import { memo, useMemo, useState, useCallback } from 'react';
```

**UI Styling Notes:**
- The overlay uses a dark transparent background (bg-black/70 or similar). The edit input uses `bg-white/10` with `border-white/20` to blend in.
- Delete button is red (`text-red-400`), undo is yellow (`text-yellow-400`). Both are compact text buttons, not icons.
- `group` / `group-hover:` Tailwind pattern for showing controls on hover. This works in Shadow DOM.
- "(edited)" indicator is `text-yellow-400/60` -- subtle but visible.
- Deleted entries are `opacity-40 line-through` with a yellow "undo" button.
  </action>
  <verify>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npx eslint src/overlay/TranscriptPanel.tsx src/overlay/hooks/useAutoScroll.ts entrypoints/content.tsx` -- passes
3. `npm run dev` builds successfully
4. Manual test: Load extension on Google Meet, verify transcript entries render normally. Double-click an entry to enter edit mode (input appears). Type new text, press Enter (text updates, "(edited)" shows). Press the "x" button (entry shows as deleted with undo). Press "undo" on deleted entry (entry reappears). Press "undo" on edited entry (original text restored).
  </verify>
  <done>
TranscriptPanel supports inline editing (double-click to edit, Enter/Escape to save/cancel), soft-delete (x button, entry shows greyed with undo), undo for both edits and deletes, "(edited)" visual indicator, and auto-scroll suppression during editing. All four EDIT requirements (EDIT-01 through EDIT-04) are implemented at the UI layer.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint .` passes (or at minimum the modified files)
3. `npm run dev` or `npm run build` succeeds
4. Manual testing on Google Meet:
   - Double-click a transcript entry: input appears with current text
   - Edit text and press Enter: text updates, "(edited)" indicator appears
   - Press Escape while editing: edit is cancelled, original text remains
   - Click "x" on hover: entry shows as deleted (greyed, line-through) with undo button
   - Click "undo" on deleted entry: entry reappears normally
   - Click "undo" on edited entry: original text is restored
   - After editing, trigger LLM request: verify LLM receives edited text (check console logs or response relevance)
   - While editing, press the capture hotkey (e.g., Space): space character is typed in the input (not capture triggered)
   - New transcript entries arrive during editing: panel does NOT auto-scroll
</verification>

<success_criteria>
- EDIT-01: Double-click enables inline editing; Enter saves, Escape cancels
- EDIT-02: Soft-delete button hides entry from view (greyed with undo) and LLM context
- EDIT-03: Edited text flows into LLM requests (verified via getFullTranscript using applyEdits)
- EDIT-04: Undo restores original text for both edits and soft-deletes
- Auto-scroll suppressed during editing
- Visual "(edited)" indicator on modified entries
- Capture hotkey suppressed during input focus
- All TypeScript and ESLint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-transcript-editing/20-02-SUMMARY.md`
</output>
