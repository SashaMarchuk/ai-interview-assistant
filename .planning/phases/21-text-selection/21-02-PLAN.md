---
phase: 21-text-selection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/overlay/hooks/useTextSelection.ts
  - src/overlay/SelectionTooltip.tsx
  - src/overlay/Overlay.tsx
  - src/overlay/ResponsePanel.tsx
  - entrypoints/content.tsx
  - src/types/globals.d.ts
  - src/assets/app.css
autonomous: true

must_haves:
  truths:
    - "Selecting text via click-and-drag in the transcript or response panel shows a floating tooltip above/below the selection"
    - "Tooltip shows action buttons with icon + label for each configured quick prompt"
    - "Clicking a tooltip action button sends the selected text to the LLM and shows a spinner on that button"
    - "Quick prompt responses appear appended below existing response content in the response panel"
    - "Double-click selections do NOT trigger the tooltip (reserved for Phase 20 transcript editing)"
    - "Tooltip dismisses when clicking outside"
    - "The tooltip has a fade-in animation (~150ms) and a triangular arrow pointer"
  artifacts:
    - path: "src/overlay/hooks/useTextSelection.ts"
      provides: "Shadow DOM-aware text selection hook with debounce and double-click filtering"
      exports: ["useTextSelection"]
    - path: "src/overlay/SelectionTooltip.tsx"
      provides: "Floating tooltip component with Floating UI positioning and action buttons"
      exports: ["SelectionTooltip"]
    - path: "src/overlay/ResponsePanel.tsx"
      provides: "ResponsePanel modified to render quick prompt response sections"
      exports: ["ResponsePanel"]
    - path: "entrypoints/content.tsx"
      provides: "Quick prompt request sender, response routing, shadowRoot prop passing"
      contains: "QUICK_PROMPT_REQUEST"
  key_links:
    - from: "src/overlay/Overlay.tsx"
      to: "src/overlay/hooks/useTextSelection.ts"
      via: "useTextSelection hook call"
      pattern: "useTextSelection"
    - from: "src/overlay/Overlay.tsx"
      to: "src/overlay/SelectionTooltip.tsx"
      via: "renders SelectionTooltip"
      pattern: "<SelectionTooltip"
    - from: "src/overlay/SelectionTooltip.tsx"
      to: "entrypoints/content.tsx"
      via: "dispatches quick-prompt-request custom event"
      pattern: "quick-prompt-request"
    - from: "entrypoints/content.tsx"
      to: "entrypoints/background.ts"
      via: "sends QUICK_PROMPT_REQUEST message"
      pattern: "QUICK_PROMPT_REQUEST"
---

<objective>
Build the selection detection, floating tooltip UI, and content script wiring for quick prompt actions. This creates the visible user-facing feature: select text -> see tooltip -> click action -> see response.

Purpose: This is the core UX of Phase 21. Without it, the data layer from Plan 01 has no UI surface. The tooltip must handle Shadow DOM selection correctly, position itself with Floating UI, and route responses through the content script.

Output: Working selection tooltip that sends quick prompt requests and displays responses in the response panel.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-text-selection/21-RESEARCH.md
@.planning/phases/21-text-selection/21-01-SUMMARY.md

@src/overlay/Overlay.tsx
@src/overlay/ResponsePanel.tsx
@entrypoints/content.tsx
@src/overlay/hooks/useOverlayPosition.ts
@src/types/messages.ts
@src/assets/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: useTextSelection hook, SelectionTooltip component, and type declarations</name>
  <files>
    src/overlay/hooks/useTextSelection.ts
    src/overlay/SelectionTooltip.tsx
    src/types/globals.d.ts
    src/assets/app.css
  </files>
  <action>
**0. Install @floating-ui/react-dom:**

Run `npm install @floating-ui/react-dom` to add the positioning library.

**1. Add TypeScript declarations in `src/types/globals.d.ts`:**

TypeScript may not include `getComposedRanges` in its lib types. Add a declaration:
```typescript
// Selection.getComposedRanges() -- Chrome 137+, standard API for Shadow DOM selection
interface Selection {
  getComposedRanges(options?: { shadowRoots?: ShadowRoot[] }): StaticRange[];
}
```

Check if `globals.d.ts` already exists. If it does, append to it. If not, create it.

**2. Create `src/overlay/hooks/useTextSelection.ts`:**

A custom React hook that:
- Receives `shadowRoot: ShadowRoot | null` and `enabled: boolean` params
- Listens for `mousedown` and `mouseup` events on the `shadowRoot`
- On `mousedown`: records timestamp and position
- On `mouseup`:
  - Returns early if `e.detail >= 2` (double-click -- reserved for Phase 20)
  - Applies 200ms debounce (per CONTEXT.md decision)
  - Gets selection via `document.getSelection()`
  - Uses `selection.getComposedRanges({ shadowRoots: [shadowRoot] })` to get composed ranges inside Shadow DOM
  - If no ranges or selection is collapsed, clears state and returns
  - Extracts text via `selection.toString().trim()`
  - Converts `StaticRange` to live `Range` (via `document.createRange()` + `setStart/setEnd`) for `getBoundingClientRect()`
  - Returns `{ text: string, rect: DOMRect }` or `null`
- On `mousedown` outside tooltip (detected via ref), clears selection state

Key design choices:
- Track a `tooltipRef` (passed in or returned) to prevent dismissing when clicking inside the tooltip
- The hook should also listen for `mousedown` to clear selection when clicking outside (except tooltip)
- Return `clearSelection` function for programmatic clearing

```typescript
interface SelectionState {
  text: string;
  rect: DOMRect;
}

export function useTextSelection(
  shadowRoot: ShadowRoot | null,
  enabled: boolean,
  tooltipRef: React.RefObject<HTMLDivElement | null>,
): { selection: SelectionState | null; clearSelection: () => void }
```

**3. Create `src/overlay/SelectionTooltip.tsx`:**

A floating tooltip component using `@floating-ui/react-dom`:

Props:
```typescript
interface SelectionTooltipProps {
  rect: DOMRect;             // Selection bounding rect
  onAction: (promptTemplate: string, actionLabel: string) => void;
  loadingActionId: string | null;  // Which action is currently loading
  errorActionId: string | null;    // Which action showed error
}
```

Implementation:
- Use `useFloating` from `@floating-ui/react-dom` with `placement: 'top'`, middleware: `[offset(8), flip(), shift({ padding: 8 })]`
- Set virtual reference from `rect` prop using `refs.setPositionReference({ getBoundingClientRect: () => rect })`
- Read `quickPrompts` from the Zustand store (`useStore`)
- Render a compact horizontal toolbar:
  - Dark background (`bg-gray-800/95`), rounded, shadow, border
  - Each action as a button with icon (emoji) + short label
  - Loading state: show a small CSS spinner on the clicked button, disable that button
  - Error state: show red tint + "Failed" text for 3 seconds, then reset
  - Small triangular arrow pointer (CSS `::after` pseudo-element or inline div with border trick) pointing toward the selection
- Fade-in animation: `opacity: 0 -> 1` over 150ms with `ease-out` easing. Use CSS class with `transition: opacity 150ms ease-out` and toggle a `visible` class on mount.

**4. Add CSS for tooltip arrow and fade-in animation to `src/assets/app.css`:**

Add at the end of the file:
```css
/* Selection tooltip arrow */
.selection-tooltip-arrow {
  position: absolute;
  width: 8px;
  height: 8px;
  background: inherit;
  transform: rotate(45deg);
}

/* Selection tooltip fade-in */
.selection-tooltip-enter {
  opacity: 0;
  transition: opacity 150ms ease-out;
}
.selection-tooltip-enter-active {
  opacity: 1;
}

/* Quick prompt spinner */
@keyframes qp-spin {
  to { transform: rotate(360deg); }
}
.qp-spinner {
  animation: qp-spin 0.6s linear infinite;
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 2px solid currentColor;
  border-top-color: transparent;
  border-radius: 50%;
}
```

Note: Using explicit `@keyframes` for the spinner because Tailwind's `animate-spin` may not work in Shadow DOM due to missing `@property` declarations (per research pitfall 7).

**5. Icon mapping utility:**

Create an `ICON_MAP` constant in SelectionTooltip.tsx (or a shared location) that maps icon keys to emoji strings:
```typescript
const ICON_MAP: Record<string, string> = {
  lightbulb: '\u{1F4A1}',
  expand: '\u{1F50D}',
  compress: '\u{1F4DD}',
  scales: '\u{2696}\u{FE0F}',
  brain: '\u{1F9E0}',
  rocket: '\u{1F680}',
  check: '\u{2705}',
  warning: '\u{26A0}\u{FE0F}',
  star: '\u{2B50}',
  wrench: '\u{1F527}',
  book: '\u{1F4DA}',
  chat: '\u{1F4AC}',
};
```

Export this as `ICON_OPTIONS` with `{ key, emoji, label }` format for use in settings UI (Plan 03).
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile. Run `npx eslint src/overlay/hooks/useTextSelection.ts src/overlay/SelectionTooltip.tsx` -- should pass. Verify `@floating-ui/react-dom` is in package.json dependencies.
  </verify>
  <done>
useTextSelection hook detects click-and-drag selections in Shadow DOM, filters out double-clicks, debounces at 200ms. SelectionTooltip renders a positioned floating toolbar with action buttons, loading spinners, and fade-in animation. Icon mapping and tooltip arrow CSS are in place.
  </done>
</task>

<task type="auto">
  <name>Task 2: Overlay integration, content script wiring, and ResponsePanel quick prompt sections</name>
  <files>
    src/overlay/Overlay.tsx
    src/overlay/ResponsePanel.tsx
    entrypoints/content.tsx
  </files>
  <action>
**1. Modify `src/overlay/Overlay.tsx`:**

- Accept a new prop `shadowRoot: ShadowRoot | null` (passed from content.tsx)
- Import and use `useTextSelection` hook, passing the shadowRoot and a tooltipRef
- Import `SelectionTooltip`
- Read `quickPromptsEnabled` from the store
- Create a `tooltipRef` via `useRef<HTMLDivElement>(null)`
- Track `loadingActionId` and `errorActionId` state
- When an action is clicked in the tooltip:
  - Set `loadingActionId` to the action's id
  - Dispatch a custom event `'quick-prompt-request'` with detail: `{ selectedText, promptTemplate, actionLabel, actionId }`
  - The content script listens for this event and sends the QUICK_PROMPT_REQUEST message
- Listen for `'quick-prompt-response-status'` custom events from content.tsx:
  - On `status: 'complete'`: clear loadingActionId
  - On `status: 'error'`: set errorActionId, clear after 3 seconds via setTimeout
- Render `SelectionTooltip` when `selection` is non-null AND `quickPromptsEnabled` is true
- Pass `tooltipRef` to SelectionTooltip as its container ref (for click-outside detection)
- Render tooltip OUTSIDE the scrollable content area (as a sibling to the main overlay container) to avoid scroll offset issues. Tooltip uses viewport coordinates directly.

**2. Modify `entrypoints/content.tsx`:**

**a. Pass shadowRoot to Overlay:**
In the `createShadowRootUi` `onMount` callback, access the shadow root. WXT's `onMount` receives `(container, shadow, shadowHost)` -- the second parameter IS the ShadowRoot. If not, access via `ui.shadow` after mount.

Update the render call:
```tsx
root.render(
  <CaptureProvider ...>
    <Overlay shadowRoot={shadow} />
  </CaptureProvider>,
);
```

**b. Add quick prompt response state:**
Add a module-level array for quick prompt responses:
```typescript
interface QuickPromptResponse {
  id: string;          // responseId (prefixed with 'qp-')
  actionLabel: string; // e.g., "Explain"
  textSnippet: string; // First ~50 chars of selected text
  content: string;     // Accumulated response text
  status: 'streaming' | 'complete' | 'error';
  error?: string;
  costUSD?: number;
}

let quickPromptResponses: QuickPromptResponse[] = [];
```

**c. Listen for quick-prompt-request events:**
```typescript
window.addEventListener('quick-prompt-request', ((
  e: CustomEvent<{ selectedText: string; promptTemplate: string; actionLabel: string; actionId: string }>
) => {
  sendQuickPromptRequest(e.detail.selectedText, e.detail.promptTemplate, e.detail.actionLabel);
}) as EventListener);
```

**d. Create `sendQuickPromptRequest` function:**
```typescript
async function sendQuickPromptRequest(
  selectedText: string,
  promptTemplate: string,
  actionLabel: string,
): Promise<void> {
  const responseId = `qp-${crypto.randomUUID()}`;

  // Initialize quick prompt response entry
  const qpResponse: QuickPromptResponse = {
    id: responseId,
    actionLabel,
    textSnippet: selectedText.slice(0, 50) + (selectedText.length > 50 ? '...' : ''),
    content: '',
    status: 'streaming',
  };
  quickPromptResponses = [...quickPromptResponses, qpResponse];
  dispatchQuickPromptUpdate();

  const message: QuickPromptRequestMessage = {
    type: 'QUICK_PROMPT_REQUEST',
    responseId,
    selectedText,
    promptTemplate,
    actionLabel,
  };

  try {
    const result = await safeSendMessage(message);
    if (result.contextInvalid) {
      window.dispatchEvent(new CustomEvent('extension-context-invalidated'));
    }
  } catch (error) {
    console.error('Quick prompt request failed:', error);
  }
}
```

**e. Route quick prompt LLM_STREAM and LLM_STATUS messages:**
In the existing `handleLLMStream` and `handleLLMStatus` functions, add a check at the top:
```typescript
// Check if this is a quick prompt response (responseId starts with 'qp-')
if (message.responseId.startsWith('qp-')) {
  handleQuickPromptStream(message); // or handleQuickPromptStatus(message)
  return;
}
```

Create `handleQuickPromptStream(message: LLMStreamMessage)`:
- Find the matching entry in `quickPromptResponses` by responseId
- Append `message.token` to its `content`
- Call `dispatchQuickPromptUpdate()`

Create `handleQuickPromptStatus(message: LLMStatusMessage)`:
- Find the matching entry, update its `status`
- If error, set `error` field
- Call `dispatchQuickPromptUpdate()`
- Dispatch `'quick-prompt-response-status'` custom event with `{ responseId, status, actionId }` so the tooltip can update its button state

Similarly route LLM_COST messages for quick prompts to update `costUSD` on the entry.

**f. Create `dispatchQuickPromptUpdate` function:**
```typescript
function dispatchQuickPromptUpdate(): void {
  window.dispatchEvent(
    new CustomEvent('quick-prompt-responses-update', {
      detail: { responses: quickPromptResponses },
    }),
  );
}
```

**3. Modify `src/overlay/ResponsePanel.tsx`:**

- Accept a new prop `quickPromptResponses` (the array of `QuickPromptResponse` objects)
- After the existing response content (Quick Hint + Full Answer), render a section for each quick prompt response:
  - Header showing action label + text snippet: e.g., "Explain: 'microservices architecture...'"
  - Use `MemoizedMarkdown` for the response content
  - Show a small cost badge if available
  - Streaming indicator while still streaming
  - Color-coded left border: teal (`border-teal-400/50`) to distinguish from existing green/purple
- The responses should be rendered in order (newest at bottom, matching append behavior)

**4. Wire quick prompt responses into Overlay:**
In Overlay.tsx, listen for `'quick-prompt-responses-update'` events and maintain state:
```typescript
const [quickPromptResponses, setQuickPromptResponses] = useState<QuickPromptResponse[]>([]);

useEffect(() => {
  const handler = (e: CustomEvent<{ responses: QuickPromptResponse[] }>) => {
    setQuickPromptResponses(e.detail.responses);
  };
  window.addEventListener('quick-prompt-responses-update', handler as EventListener);
  return () => window.removeEventListener('quick-prompt-responses-update', handler as EventListener);
}, []);
```

Pass `quickPromptResponses` to `ResponsePanel`.

**5. Add keyboard shortcut for first action (Ctrl+Shift+E):**
In `useTextSelection` or in the Overlay, listen for `keydown` with Ctrl+Shift+E. If there's an active selection, trigger the first quick prompt action. Use the existing `parseHotkey`/`matchesHotkey` from `useCaptureMode.ts` if available, or implement a simple check.

Import `QuickPromptRequestMessage` type in content.tsx.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile. Run `npx eslint src/overlay/Overlay.tsx src/overlay/ResponsePanel.tsx entrypoints/content.tsx` -- should pass. Manually verify the onMount callback passes shadowRoot correctly by checking WXT docs or the `onMount` type signature.
  </verify>
  <done>
Selecting text in the overlay shows a floating tooltip. Clicking an action sends a quick prompt request through content.tsx to background. Streaming responses are routed back and rendered as appended sections in the ResponsePanel. Double-clicks don't trigger the tooltip. Keyboard shortcut Ctrl+Shift+E triggers the first action on current selection.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx eslint .` passes on modified files
3. `@floating-ui/react-dom` is in package.json dependencies
4. `useTextSelection` correctly uses `getComposedRanges` for Shadow DOM
5. Double-click events are filtered out (e.detail >= 2)
6. Tooltip positions itself relative to selection via Floating UI virtual element
7. Quick prompt responses appear below existing response content (not replace)
8. Quick prompt response routing uses 'qp-' prefix for responseId
</verification>

<success_criteria>
- Text selection in overlay shows floating tooltip with configured quick prompt actions
- Clicking an action sends selectedText + promptTemplate to background via QUICK_PROMPT_REQUEST
- Responses stream back and are rendered in the ResponsePanel as appended sections
- Tooltip has fade-in animation, arrow pointer, loading spinners on buttons
- Double-click does NOT trigger tooltip (Phase 20 compatibility)
- Keyboard shortcut triggers first quick prompt action
</success_criteria>

<output>
After completion, create `.planning/phases/21-text-selection/21-02-SUMMARY.md`
</output>
