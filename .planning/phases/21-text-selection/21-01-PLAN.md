---
phase: 21-text-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/messages.ts
  - src/store/types.ts
  - src/store/quickPromptsSlice.ts
  - src/store/index.ts
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Quick prompt configurations are stored in Zustand and persist across browser restarts"
    - "A QUICK_PROMPT_REQUEST message sent from content script reaches background and triggers an LLM request without cancelling existing active requests"
    - "Quick prompt LLM responses stream back via LLM_STREAM/LLM_STATUS with a unique responseId"
    - "4 default quick prompt actions (Explain, Elaborate, Summarize, Counter-argument) are seeded on first install"
  artifacts:
    - path: "src/store/quickPromptsSlice.ts"
      provides: "QuickPromptsSlice with CRUD operations, reorder, reset-to-defaults"
      exports: ["createQuickPromptsSlice"]
    - path: "src/types/messages.ts"
      provides: "QUICK_PROMPT_REQUEST and QUICK_PROMPT_CANCEL message types"
      contains: "QuickPromptRequestMessage"
    - path: "src/store/types.ts"
      provides: "QuickPromptAction interface and QuickPromptsSlice interface"
      contains: "QuickPromptAction"
    - path: "entrypoints/background.ts"
      provides: "Concurrent quick prompt handler that does not cancel active requests"
      contains: "QUICK_PROMPT_REQUEST"
  key_links:
    - from: "src/store/quickPromptsSlice.ts"
      to: "src/store/types.ts"
      via: "imports QuickPromptsSlice type"
      pattern: "import.*QuickPromptsSlice.*from.*types"
    - from: "src/store/index.ts"
      to: "src/store/quickPromptsSlice.ts"
      via: "slice composition"
      pattern: "createQuickPromptsSlice"
    - from: "entrypoints/background.ts"
      to: "src/types/messages.ts"
      via: "message type switch case"
      pattern: "case 'QUICK_PROMPT_REQUEST'"
---

<objective>
Create the data layer foundation for Phase 21: Quick Prompt types, Zustand slice for storing prompt configurations, QUICK_PROMPT_REQUEST message type, and background handler that runs quick prompt LLM requests concurrently with ongoing requests.

Purpose: Without this foundation, the tooltip UI (Plan 02) has no way to persist configurations or send requests to the LLM. The concurrent request pathway is critical -- current LLM_REQUEST cancels all active requests, but quick prompts must not interfere with ongoing responses.

Output: QuickPromptsSlice integrated into the store, QUICK_PROMPT_REQUEST message handled in background.ts with separate abort controller tracking.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-text-selection/21-RESEARCH.md

@src/store/types.ts
@src/store/settingsSlice.ts
@src/store/index.ts
@src/types/messages.ts
@entrypoints/background.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Quick Prompt types, message types, and Zustand slice</name>
  <files>
    src/types/messages.ts
    src/store/types.ts
    src/store/quickPromptsSlice.ts
    src/store/index.ts
  </files>
  <action>
**1. Add QuickPromptAction and QuickPromptsSlice types to `src/store/types.ts`:**

```typescript
export interface QuickPromptAction {
  id: string;
  label: string;         // e.g., "Explain"
  icon: string;          // icon key from predefined set (e.g., 'lightbulb', 'expand')
  promptTemplate: string; // e.g., "Explain this: {{selection}}" -- {{selection}} is replaced with selected text
  order: number;         // 0-3 for display ordering
}

export interface QuickPromptsSlice {
  quickPrompts: QuickPromptAction[];
  quickPromptsEnabled: boolean;
  setQuickPrompts: (prompts: QuickPromptAction[]) => void;
  setQuickPromptsEnabled: (enabled: boolean) => void;
  addQuickPrompt: (prompt: Omit<QuickPromptAction, 'id' | 'order'>) => void;
  updateQuickPrompt: (id: string, updates: Partial<Omit<QuickPromptAction, 'id'>>) => void;
  removeQuickPrompt: (id: string) => void;
  reorderQuickPrompts: (orderedIds: string[]) => void;
  resetQuickPromptsToDefaults: () => void;
}
```

Update `StoreState` to include `QuickPromptsSlice`:
```typescript
export type StoreState = SettingsSlice & TemplatesSlice & ConsentSlice & QuickPromptsSlice;
```

**2. Add message types to `src/types/messages.ts`:**

Add `'QUICK_PROMPT_REQUEST'` and `'QUICK_PROMPT_CANCEL'` to the `MessageType` union.

Add message interfaces:
```typescript
export interface QuickPromptRequestMessage extends BaseMessage {
  type: 'QUICK_PROMPT_REQUEST';
  responseId: string;       // Unique ID prefixed with 'qp-' for routing
  selectedText: string;     // The text the user selected
  promptTemplate: string;   // e.g., "Explain this: {{selection}}"
  actionLabel: string;      // e.g., "Explain" -- used for response header
}

export interface QuickPromptCancelMessage extends BaseMessage {
  type: 'QUICK_PROMPT_CANCEL';
  responseId: string;
}
```

Add both to the `ExtensionMessage` union type.

**3. Create `src/store/quickPromptsSlice.ts`:**

Follow the pattern from `settingsSlice.ts`. Define `DEFAULT_QUICK_PROMPTS` array with 4 actions:
- `{ id: 'explain', label: 'Explain', icon: 'lightbulb', promptTemplate: 'Explain this: {{selection}}', order: 0 }`
- `{ id: 'elaborate', label: 'Elaborate', icon: 'expand', promptTemplate: 'Elaborate on this in more detail: {{selection}}', order: 1 }`
- `{ id: 'summarize', label: 'Summarize', icon: 'compress', promptTemplate: 'Summarize the key points of this: {{selection}}', order: 2 }`
- `{ id: 'counter', label: 'Counter', icon: 'scales', promptTemplate: 'Provide a counter-argument to this point, as an interviewer might challenge it: {{selection}}', order: 3 }`

Export `DEFAULT_QUICK_PROMPTS` (needed by settings UI for reset-to-defaults).

Implement all slice actions:
- `addQuickPrompt`: Enforce max 4 limit (reject silently if already at 4). Generate `id` via `crypto.randomUUID()`. Set `order` to next available.
- `updateQuickPrompt`: Find by id, merge updates.
- `removeQuickPrompt`: Filter out by id, reorder remaining (recalculate `order` values 0..N-1).
- `reorderQuickPrompts`: Receives array of ids in new order, sets `order` field accordingly.
- `resetQuickPromptsToDefaults`: Replace with `DEFAULT_QUICK_PROMPTS`.

**4. Integrate into `src/store/index.ts`:**

- Import `createQuickPromptsSlice`.
- Add to the combined store creation: `...createQuickPromptsSlice(...a)`.
- Add `quickPrompts` and `quickPromptsEnabled` to the `partialize` function so they persist.
- In `onRehydrateStorage`, seed defaults if `quickPrompts` is empty (similar to templates seeding):
  ```typescript
  if (state && state.quickPrompts.length === 0) {
    state.resetQuickPromptsToDefaults();
  }
  ```
- Export `QuickPromptsSlice` and `QuickPromptAction` from the re-export section.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors. Run `npx eslint src/store/quickPromptsSlice.ts src/store/types.ts src/store/index.ts src/types/messages.ts` -- should pass.
  </verify>
  <done>
QuickPromptsSlice exists with all CRUD operations, persists via chrome.storage, seeds 4 defaults on first install. QUICK_PROMPT_REQUEST and QUICK_PROMPT_CANCEL message types exist in the message union.
  </done>
</task>

<task type="auto">
  <name>Task 2: Background handler for concurrent quick prompt requests</name>
  <files>entrypoints/background.ts</files>
  <action>
**1. Add a separate abort controller map for quick prompts:**

At the module level (near `activeAbortControllers`), add:
```typescript
const quickPromptAbortControllers: Map<string, AbortController> = new Map();
```

**2. Create `handleQuickPromptRequest` function:**

This function is similar to `handleLLMRequest` but simpler -- it fires a SINGLE model request (fast model only, per CONTEXT.md "Quick prompts always use the fast model"), builds a simple prompt from the template, and does NOT cancel other requests.

```typescript
async function handleQuickPromptRequest(
  responseId: string,
  selectedText: string,
  promptTemplate: string,
  actionLabel: string,
  abortController: AbortController,
): Promise<void> {
  const state = useStore.getState();
  const { apiKeys, models } = state;

  // Resolve fast model provider
  const fastResolution = resolveProviderForModel(models.fastModel, {
    openAI: apiKeys.openAI,
    openRouter: apiKeys.openRouter,
  });

  if (!fastResolution) {
    await sendLLMMessageToMeet({
      type: 'LLM_STATUS',
      responseId,
      model: 'fast',
      status: 'error',
      error: 'No LLM provider configured for fast model.',
    });
    quickPromptAbortControllers.delete(responseId);
    return;
  }

  // Build prompt from template -- replace {{selection}} with actual text
  const userPrompt = promptTemplate.includes('{{selection}}')
    ? promptTemplate.replace('{{selection}}', selectedText)
    : `${promptTemplate}: ${selectedText}`;

  // Send streaming status
  await sendLLMMessageToMeet({
    type: 'LLM_STATUS',
    responseId,
    model: 'fast',
    status: 'streaming',
  });

  // Start keep-alive
  startKeepAlive();

  try {
    await fireModelRequest({
      resolution: fastResolution,
      modelType: 'fast',
      modelId: models.fastModel,
      userPrompt,
      maxTokens: 1024, // Quick prompts are short responses
      onDone: () => {
        quickPromptAbortControllers.delete(responseId);
        if (activeAbortControllers.size === 0 && quickPromptAbortControllers.size === 0) {
          stopKeepAlive();
        }
      },
      responseId,
      abortController,
      systemPrompt: 'You are a helpful assistant. Be concise and clear.',
    });
  } catch (error) {
    if (!abortController.signal.aborted) {
      await sendLLMMessageToMeet({
        type: 'LLM_STATUS',
        responseId,
        model: 'fast',
        status: 'error',
        error: error instanceof Error ? error.message : 'Quick prompt request failed',
      });
    }
    quickPromptAbortControllers.delete(responseId);
    if (activeAbortControllers.size === 0 && quickPromptAbortControllers.size === 0) {
      stopKeepAlive();
    }
  }
}
```

NOTE on `fireModelRequest`: Check the existing function signature. It likely accepts a config object. The function needs `systemPrompt` and `responseId` and `abortController` among other params. Read the actual `fireModelRequest` implementation to match its interface. If `fireModelRequest` doesn't accept `systemPrompt` as a separate param, use `prompts.systemMessage` approach or modify `fireModelRequest` to accept an optional `systemPrompt` override. Alternatively, build the system prompt into the user prompt itself (simpler: just send the full prompt as userPrompt with no system prompt).

**3. Add message handler cases in the switch statement (near the `LLM_REQUEST` case):**

```typescript
case 'QUICK_PROMPT_REQUEST': {
  // Do NOT cancel existing requests -- quick prompts run concurrently
  const abortController = new AbortController();
  quickPromptAbortControllers.set(message.responseId, abortController);

  handleQuickPromptRequest(
    message.responseId,
    message.selectedText,
    message.promptTemplate,
    message.actionLabel,
    abortController,
  );
  return { success: true };
}

case 'QUICK_PROMPT_CANCEL': {
  const qpController = quickPromptAbortControllers.get(message.responseId);
  if (qpController) {
    qpController.abort();
    quickPromptAbortControllers.delete(message.responseId);
    if (activeAbortControllers.size === 0 && quickPromptAbortControllers.size === 0) {
      stopKeepAlive();
    }
  }
  return { success: true };
}
```

**4. Update imports at the top of background.ts:**

Add `QuickPromptRequestMessage` and `QuickPromptCancelMessage` to the imported types from messages.ts.

**5. Update the exhaustive switch check:**

The `default` case uses `const _exhaustiveCheck: never = message;` which will error if the new cases aren't handled. The new cases added above satisfy this.

**6. Update `hasActiveLLMRequest` in `GET_CAPTURE_STATE` handler:**

Update the existing `hasActiveLLMRequest` calculation to also consider quick prompt controllers:
```typescript
hasActiveLLMRequest: activeAbortControllers.size > 0 || quickPromptAbortControllers.size > 0,
```

**7. Ensure quick prompt requests also trigger cost tracking:**

The existing `fireModelRequest` should already call `onUsage` which triggers `LLM_COST` messages. Quick prompt costs will be routed to the content script via the same `sendLLMMessageToMeet` pathway. The content script will need to handle these (handled in Plan 02).

**8. Ensure existing `LLM_REQUEST` handler does NOT clear `quickPromptAbortControllers`:**

The current cancel-all logic at line ~1059-1066 only clears `activeAbortControllers`. Verify it doesn't touch `quickPromptAbortControllers` (it shouldn't since we're defining a new map).
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors. Run `npx eslint entrypoints/background.ts` -- should pass. Verify that the switch statement is still exhaustive (no TypeScript `never` error).
  </verify>
  <done>
Background handles QUICK_PROMPT_REQUEST by launching a fast-model-only LLM request without cancelling active requests. Quick prompt abort controllers are tracked separately. QUICK_PROMPT_CANCEL cleans up the controller. Cost tracking works through existing pipeline.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx eslint .` passes (or at minimum the modified files)
3. Quick prompt slice types are correctly defined and exported
4. QUICK_PROMPT_REQUEST is in the MessageType union and has a corresponding interface
5. Background switch statement is exhaustive (no TypeScript `never` type errors)
6. The `activeAbortControllers` cancel-all logic in LLM_REQUEST does NOT affect `quickPromptAbortControllers`
</verification>

<success_criteria>
- QuickPromptsSlice is integrated into the Zustand store with persistence
- 4 default quick prompts are seeded on first install
- QUICK_PROMPT_REQUEST message type exists and is handled in background.ts
- Quick prompt requests use fast model only and run concurrently with regular LLM requests
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/21-text-selection/21-01-SUMMARY.md`
</output>
