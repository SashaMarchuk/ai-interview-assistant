---
phase: 18-cost-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/costHistory/costDb.ts
  - src/services/costHistory/types.ts
  - src/services/costHistory/aggregation.ts
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Every completed LLM request writes a CostRecord to IndexedDB with provider, modelId, sessionId, token counts, and costUSD"
    - "Cost records persist across browser restarts and service worker terminations"
    - "A new session ID is generated on START_CAPTURE and used for all cost records until STOP_CAPTURE"
    - "Records older than 90 days are automatically cleaned up"
  artifacts:
    - path: "src/services/costHistory/types.ts"
      provides: "CostRecord interface with provider/model/session fields"
      contains: "interface CostRecord"
    - path: "src/services/costHistory/costDb.ts"
      provides: "IndexedDB wrapper with saveCostRecord, getCostRecordsSince, deleteRecordsBefore, clearAllRecords"
      exports: ["saveCostRecord", "getCostRecordsSince", "deleteRecordsBefore", "clearAllRecords"]
    - path: "src/services/costHistory/aggregation.ts"
      provides: "Data aggregation functions for daily, provider, model, and session breakdowns"
      exports: ["aggregateByDay", "aggregateByProvider", "aggregateByModel", "aggregateBySessions"]
    - path: "entrypoints/background.ts"
      provides: "IndexedDB cost record write in onUsage callback, session ID lifecycle"
  key_links:
    - from: "entrypoints/background.ts"
      to: "src/services/costHistory/costDb.ts"
      via: "saveCostRecord() call in onUsage callback"
      pattern: "saveCostRecord\\("
    - from: "entrypoints/background.ts"
      to: "src/services/costHistory/types.ts"
      via: "CostRecord import"
      pattern: "import.*CostRecord"
---

<objective>
Create the IndexedDB persistence layer for cost records and integrate it into the background service worker's onUsage callback.

Purpose: Phase 17 captures cost data in-memory per session. Phase 18 needs to persist this data across browser restarts so it can be visualized historically. The background service worker is the only context where modelId, providerId, and sessionId are all in scope, making it the natural write point.

Output: CostRecord type, IndexedDB wrapper module, data aggregation helpers, and background.ts integration that writes every completed LLM cost to IndexedDB.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-cost-dashboard/18-RESEARCH.md
@src/services/llm/pricing.ts
@src/services/llm/types.ts
@src/services/llm/providers/LLMProvider.ts
@src/types/messages.ts
@entrypoints/background.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CostRecord types, IndexedDB wrapper, and aggregation helpers</name>
  <files>
    src/services/costHistory/types.ts
    src/services/costHistory/costDb.ts
    src/services/costHistory/aggregation.ts
  </files>
  <action>
Create three new files in `src/services/costHistory/`:

**types.ts** - CostRecord interface:
```typescript
export interface CostRecord {
  id: string;                           // crypto.randomUUID()
  timestamp: number;                    // Date.now()
  sessionId: string;                    // Generated on START_CAPTURE
  provider: 'openai' | 'openrouter';    // From resolution.provider.id
  modelId: string;                      // From resolution.model (e.g., 'gpt-4o')
  modelSlot: 'fast' | 'full';          // Which model slot was used
  promptTokens: number;
  completionTokens: number;
  reasoningTokens: number;
  totalTokens: number;
  costUSD: number;
}
```
Also export aggregation result types: `DailyCost` (date, dateKey, cost, tokens), `ProviderCost` (name, value), `ModelCost` (name, value), `SessionSummary` (sessionId, startTime, requestCount, totalCost, totalTokens).

**costDb.ts** - Promise-based IndexedDB wrapper using native API (no external dependency):
- DB_NAME = 'ai-interview-costs', DB_VERSION = 1, STORE_NAME = 'cost-records'
- Lazy database opening (open on first call, cache the Promise) per research Pitfall 1 (IndexedDB not available during SW initialization)
- `openCostDb()` internal - creates object store with keyPath 'id' and indexes: by-timestamp, by-provider, by-model, by-session
- `saveCostRecord(record: CostRecord): Promise<void>` - puts a record
- `getCostRecordsSince(sinceTimestamp: number): Promise<CostRecord[]>` - reads records using by-timestamp index with lowerBound range
- `getAllCostRecords(): Promise<CostRecord[]>` - reads all records
- `deleteRecordsBefore(beforeTimestamp: number): Promise<void>` - opens cursor on by-timestamp index with upperBound range, deletes each
- `clearAllRecords(): Promise<void>` - clears the entire object store
- `getRecordCount(): Promise<number>` - returns count of records (for dashboard stats)

**aggregation.ts** - Pure functions that take CostRecord[] and return aggregated data:
- `aggregateByDay(records)` - Groups by YYYY-MM-DD, returns DailyCost[] sorted chronologically. Use `Intl.DateTimeFormat` for month abbreviation.
- `aggregateByProvider(records)` - Groups by provider ('OpenAI' | 'OpenRouter'), returns ProviderCost[]
- `aggregateByModel(records)` - Groups by modelId, returns ModelCost[] sorted by cost descending
- `aggregateBySessions(records)` - Groups by sessionId, returns SessionSummary[] sorted by startTime descending

Use Map-based accumulation pattern from research. No external dependencies.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all three files compile with no errors. Verify files exist at the expected paths.
  </verify>
  <done>
CostRecord type defined, IndexedDB wrapper exports 5 CRUD functions, aggregation module exports 4 grouping functions. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate IndexedDB writes and session ID into background service worker</name>
  <files>entrypoints/background.ts</files>
  <action>
Modify `entrypoints/background.ts` to:

1. **Import** `saveCostRecord` from `../src/services/costHistory/costDb` and `CostRecord` from `../src/services/costHistory/types`.

2. **Add session ID state** at module level (alongside existing `isTabCaptureActive`, `isTranscriptionActive`):
   ```typescript
   let currentSessionId: string | null = null;
   ```

3. **Generate session ID on START_CAPTURE** - Inside the `case 'START_CAPTURE'` block, right after `isTabCaptureActive = true;` (around line 763), add:
   ```typescript
   currentSessionId = `session-${Date.now()}-${activeTab.id}`;
   ```

4. **Clear session ID on STOP_CAPTURE** - Inside the `case 'STOP_CAPTURE'` block, after `isTabCaptureActive = false;`, add:
   ```typescript
   currentSessionId = null;
   ```

5. **Write to IndexedDB in onUsage callback** - Inside the `fireModelRequest` function's `onUsage` callback (around line 475-493), AFTER the existing `sendLLMMessageToMeet` call for `LLM_COST`, add a `saveCostRecord` call:
   ```typescript
   // Persist to IndexedDB for historical dashboard
   saveCostRecord({
     id: crypto.randomUUID(),
     timestamp: Date.now(),
     sessionId: currentSessionId ?? `adhoc-${Date.now()}`,
     provider: resolution!.provider.id,
     modelId: modelId,
     modelSlot: modelType,
     promptTokens: usage.promptTokens,
     completionTokens: usage.completionTokens,
     reasoningTokens: usage.reasoningTokens,
     totalTokens: usage.totalTokens,
     costUSD,
   }).catch((err) => {
     console.error('Failed to persist cost record:', err);
   });
   ```
   Note: Use `.catch()` to fire-and-forget -- don't await the IndexedDB write; it should not block the streaming response. Use `resolution!` (non-null assertion) because onUsage only fires when resolution is truthy (the `if (!resolution)` guard returns early before setting up the stream).

6. **Important context**: The `onUsage` callback in `fireModelRequest` already has `modelId` (from config param), `modelType` (from config param), and `resolution` (from config param) in scope. The provider ID is `resolution.provider.id`. No new message types or message enrichment needed.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify background.ts compiles. Run `npx eslint entrypoints/background.ts` to check for linting errors.
  </verify>
  <done>
Background service worker writes a CostRecord to IndexedDB on every LLM usage event. Session ID is generated on START_CAPTURE and cleared on STOP_CAPTURE. IndexedDB write is fire-and-forget (non-blocking).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint .` passes with zero errors
3. New files exist: `src/services/costHistory/types.ts`, `src/services/costHistory/costDb.ts`, `src/services/costHistory/aggregation.ts`
4. `entrypoints/background.ts` imports and calls `saveCostRecord` in the onUsage callback
5. Session ID lifecycle (START_CAPTURE creates, STOP_CAPTURE clears) is present in background.ts
</verification>

<success_criteria>
- CostRecord type is defined with all required fields (id, timestamp, sessionId, provider, modelId, modelSlot, token counts, costUSD)
- IndexedDB wrapper provides CRUD operations with lazy database opening
- Aggregation helpers produce daily, provider, model, and session groupings from CostRecord arrays
- Background service worker writes to IndexedDB on every LLM completion (non-blocking)
- Session ID is generated per capture session and used in cost records
</success_criteria>

<output>
After completion, create `.planning/phases/18-cost-dashboard/18-01-SUMMARY.md`
</output>
