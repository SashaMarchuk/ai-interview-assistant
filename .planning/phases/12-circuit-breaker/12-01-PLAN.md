---
phase: 12-circuit-breaker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/circuitBreaker/types.ts
  - src/services/circuitBreaker/CircuitBreaker.ts
  - src/services/circuitBreaker/circuitBreakerManager.ts
  - entrypoints/background.ts
  - wxt.config.ts
autonomous: true

must_haves:
  truths:
    - "After 3+ consecutive API failures for a provider, subsequent calls are immediately rejected without making network requests and the UI shows a service unavailable indicator"
    - "After the recovery timeout elapses, the circuit automatically transitions to HALF_OPEN and allows a test request through"
    - "Circuit breaker state persists across service worker restarts -- killing the service worker while circuit is OPEN does not reset it to CLOSED"
    - "When the failing service recovers, the circuit transitions back to CLOSED and normal operation resumes automatically"
  artifacts:
    - path: "src/services/circuitBreaker/types.ts"
      provides: "CircuitState enum, CircuitBreakerConfig, PersistedCircuitState interfaces"
      contains: "CircuitState"
    - path: "src/services/circuitBreaker/CircuitBreaker.ts"
      provides: "Circuit breaker state machine with chrome.storage.session persistence"
      exports: ["CircuitBreaker"]
    - path: "src/services/circuitBreaker/circuitBreakerManager.ts"
      provides: "Per-service circuit breaker instances, alarm listener, rehydrate function"
      exports: ["circuitBreakerManager"]
    - path: "entrypoints/background.ts"
      provides: "Circuit breaker integration around streamWithRetry and START_TRANSCRIPTION"
      contains: "circuitBreakerManager"
    - path: "wxt.config.ts"
      provides: "alarms permission in manifest"
      contains: "alarms"
  key_links:
    - from: "entrypoints/background.ts"
      to: "src/services/circuitBreaker/circuitBreakerManager.ts"
      via: "import circuitBreakerManager"
      pattern: "circuitBreakerManager\\.getBreaker"
    - from: "src/services/circuitBreaker/CircuitBreaker.ts"
      to: "chrome.storage.session"
      via: "persist state on transitions"
      pattern: "chrome\\.storage\\.session\\.set"
    - from: "src/services/circuitBreaker/circuitBreakerManager.ts"
      to: "chrome.alarms"
      via: "recovery timeout alarm listener"
      pattern: "chrome\\.alarms\\.onAlarm\\.addListener"
    - from: "entrypoints/background.ts"
      to: "sendConnectionState"
      via: "broadcast circuit state to HealthIndicator"
      pattern: "sendConnectionState.*error.*unavailable"
---

<objective>
Implement the circuit breaker pattern for all external API calls (LLM providers and ElevenLabs STT) with chrome.storage.session persistence and chrome.alarms-based recovery, integrated into the existing background service worker.

Purpose: Prevent the extension from hammering unresponsive APIs, provide automatic recovery, and show clear UI indicators when services are unavailable.
Output: CircuitBreaker service with per-provider instances, wired into background.ts request handlers, with state that survives service worker restarts.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-circuit-breaker/12-RESEARCH.md
@entrypoints/background.ts
@wxt.config.ts
@src/services/crypto/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CircuitBreaker service with persistent state and alarm-based recovery</name>
  <files>
    src/services/circuitBreaker/types.ts
    src/services/circuitBreaker/CircuitBreaker.ts
    src/services/circuitBreaker/circuitBreakerManager.ts
    wxt.config.ts
  </files>
  <action>
**1. Add `alarms` permission** to `wxt.config.ts` manifest permissions array (currently has `['tabCapture', 'activeTab', 'offscreen', 'storage', 'scripting']`). Add `'alarms'` to that array.

**2. Create `src/services/circuitBreaker/types.ts`:**

```typescript
export enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN',
}

export interface CircuitBreakerConfig {
  serviceId: string;
  failureThreshold: number;      // 3 for all providers (per success criteria)
  recoveryTimeoutMs: number;     // 60000 for LLM, 30000 for ElevenLabs
  halfOpenSuccessThreshold: number; // 1 -- single success in HALF_OPEN closes circuit
}

export interface PersistedCircuitState {
  state: CircuitState;
  failureCount: number;
  successCount: number;
  lastFailureTime: number;
  openedAt: number | null;
}
```

**3. Create `src/services/circuitBreaker/CircuitBreaker.ts`:**

Core class (~100-120 lines) implementing:
- Constructor takes `CircuitBreakerConfig`, initializes default CLOSED state
- `allowRequest(): boolean` -- returns true if CLOSED or HALF_OPEN, false if OPEN
- `recordSuccess(): Promise<void>` -- in CLOSED: reset failureCount. In HALF_OPEN: increment successCount, if >= threshold, transition to CLOSED (clear alarm, persist, return)
- `recordFailure(): Promise<void>` -- increment failureCount. If >= threshold AND state is CLOSED: transition to OPEN (set openedAt, create chrome.alarm for recovery, persist). If state is HALF_OPEN: transition back to OPEN (restart recovery timer, persist)
- `transitionToHalfOpen(): Promise<void>` -- set state to HALF_OPEN, reset successCount, persist
- `rehydrate(): Promise<void>` -- load from `chrome.storage.session` key `circuit_${serviceId}`, restore state fields. If state is OPEN, check if recovery timeout already elapsed (compare openedAt + recoveryTimeoutMs vs Date.now()); if elapsed, transition to HALF_OPEN immediately
- `getState(): CircuitState` -- return current state
- `getServiceId(): string` -- return config.serviceId
- Private `persist(): Promise<void>` -- write current state to `chrome.storage.session` under key `circuit_${serviceId}`

**Key design decisions:**
- Use relative imports (prior decision 10-01)
- Only persist on state transitions and failure count changes (not on every call)
- Alarm name format: `circuit-recovery-${serviceId}`
- `delayInMinutes` for alarm: `this.config.recoveryTimeoutMs / 60000` (60s = 1.0 min, 30s = 0.5 min)
- On transition to CLOSED, call `chrome.alarms.clear()` to cancel pending recovery alarm

**4. Create `src/services/circuitBreaker/circuitBreakerManager.ts`:**

Manager module (~60-80 lines):
- Internal `Map<string, CircuitBreaker>` storing per-service instances
- Pre-create three instances with configs:
  - `openai`: failureThreshold=3, recoveryTimeoutMs=60000, halfOpenSuccessThreshold=1
  - `openrouter`: failureThreshold=3, recoveryTimeoutMs=60000, halfOpenSuccessThreshold=1
  - `elevenlabs`: failureThreshold=3, recoveryTimeoutMs=30000, halfOpenSuccessThreshold=1
- Export `circuitBreakerManager` object with:
  - `getBreaker(serviceId: string): CircuitBreaker` -- returns instance from map, throws if unknown serviceId
  - `rehydrate(): Promise<void>` -- calls rehydrate() on all instances
- Register `chrome.alarms.onAlarm.addListener` at module level:
  - Filter for alarms starting with `circuit-recovery-`
  - Extract serviceId, call `breaker.transitionToHalfOpen()`
  - After transition, broadcast connection state update via a callback (see integration in Task 2)
- Export a `setStateChangeCallback(cb: (serviceId: string, state: CircuitState) => void)` function that the manager calls on every state transition (OPEN, HALF_OPEN, CLOSED). This allows background.ts to broadcast CONNECTION_STATE without circular imports.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no errors in the new files
2. `wxt.config.ts` has `'alarms'` in the permissions array
3. Files exist: `src/services/circuitBreaker/types.ts`, `CircuitBreaker.ts`, `circuitBreakerManager.ts`
4. CircuitBreaker class has methods: allowRequest, recordSuccess, recordFailure, transitionToHalfOpen, rehydrate, getState
5. circuitBreakerManager has: getBreaker, rehydrate, setStateChangeCallback
  </verify>
  <done>
CircuitBreaker class exists with CLOSED/OPEN/HALF_OPEN state machine, chrome.storage.session persistence, chrome.alarms-based recovery timeout, and per-service manager with openai/openrouter/elevenlabs instances. The alarms permission is in the manifest.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate circuit breaker into background.ts request handlers and init chain</name>
  <files>
    entrypoints/background.ts
  </files>
  <action>
**1. Import circuitBreakerManager** at the top of `background.ts` (use relative import per decision 10-01):
```typescript
import { circuitBreakerManager } from '../src/services/circuitBreaker/circuitBreakerManager';
```

**2. Wire state change callback** right after the import. This broadcasts CONNECTION_STATE to the HealthIndicator when circuit state changes:
```typescript
import { CircuitState } from '../src/services/circuitBreaker/types';

circuitBreakerManager.setStateChangeCallback((serviceId, state) => {
  // Map serviceId to CONNECTION_STATE service name
  const service = serviceId === 'elevenlabs' ? 'stt-tab' as const : 'llm' as const;

  if (state === CircuitState.OPEN) {
    sendConnectionState(service, 'error', 'Service temporarily unavailable');
  } else if (state === CircuitState.HALF_OPEN) {
    sendConnectionState(service, 'reconnecting', 'Testing service recovery...');
  } else if (state === CircuitState.CLOSED) {
    sendConnectionState(service, 'connected');
  }
});
```

**3. Add circuit breaker rehydration to init chain.** Modify the existing initialization chain (currently `encryptionService.initialize().then(() => storeReadyPromise)`) to include circuit breaker rehydration:
```typescript
encryptionService.initialize()
  .then(() => circuitBreakerManager.rehydrate())
  .then(() => storeReadyPromise)
  .then(() => {
    storeReady = true;
    // ... existing queue drain code unchanged
  })
```

**4. Wrap LLM requests with circuit breaker** in `handleLLMRequest()`:

Before the existing `streamWithRetry` call for the fast model (around line 334-378), add circuit breaker check:
```typescript
if (fastResolution) {
  const fastBreaker = circuitBreakerManager.getBreaker(fastResolution.provider.id);
  if (!fastBreaker.allowRequest()) {
    // Circuit OPEN -- reject immediately, no network request
    fastComplete = true;
    await sendLLMMessageToMeet({
      type: 'LLM_STATUS',
      responseId,
      model: 'fast',
      status: 'error',
      error: `${fastResolution.provider.id} service temporarily unavailable`,
    });
  } else {
    // Existing streamWithRetry call -- wrap in try/catch for circuit recording
    fastPromise = streamWithRetry(/* existing params */)
      .then(() => { fastBreaker.recordSuccess(); })
      .catch((error) => { fastBreaker.recordFailure(); throw error; });
  }
}
```

Apply the same pattern for the full model request (around line 392-446).

**Important:** The `recordSuccess()` and `recordFailure()` calls wrap AROUND `streamWithRetry`, not inside it. Only the final outcome (after all retries are exhausted) feeds into the circuit breaker. Individual retries inside `streamWithRetry` do NOT count as separate failures.

**Note on recording:** The existing `streamWithRetry` already handles the `onComplete` and `onError` callbacks internally. The circuit breaker recording should happen at the Promise level -- when the `streamWithRetry` Promise resolves (success) or rejects (final failure after all retries). Looking at the existing code, `streamWithRetry` already throws after max retries are exhausted, so wrapping the returned Promise with `.then(recordSuccess).catch(recordFailure)` captures the right signal.

**5. Add circuit breaker check for ElevenLabs** in the `START_TRANSCRIPTION` handler (around line 744):

After the API key check (`if (!elevenLabsKey)`), add:
```typescript
// Check ElevenLabs circuit breaker
const elevenLabsBreaker = circuitBreakerManager.getBreaker('elevenlabs');
if (!elevenLabsBreaker.allowRequest()) {
  return { success: false, error: 'ElevenLabs service temporarily unavailable. Will retry automatically.' };
}
```

For ElevenLabs failure recording: In the `TRANSCRIPTION_ERROR` handler (around line 808), add:
```typescript
case 'TRANSCRIPTION_ERROR':
  console.error('Transcription error:', message.source, message.error);
  // Record failure for ElevenLabs circuit breaker
  circuitBreakerManager.getBreaker('elevenlabs').recordFailure();
  return { received: true };
```

For ElevenLabs success recording: In the `TRANSCRIPTION_STARTED` handler (around line 799), add:
```typescript
case 'TRANSCRIPTION_STARTED':
  isTranscriptionActive = true;
  console.log('Transcription: Connected');
  // Record success for ElevenLabs circuit breaker
  circuitBreakerManager.getBreaker('elevenlabs').recordSuccess();
  return { received: true };
```

**Design note:** ElevenLabs circuit breaker operates at the background level, not offscreen. The background mediates all transcription lifecycle messages. The offscreen document's internal reconnection logic (3 retries with exponential backoff) feeds failure signals back to background via TRANSCRIPTION_ERROR messages, which the circuit breaker counts. This avoids duplicating circuit breaker logic in the offscreen context (per research recommendation).
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors in background.ts)
2. `npm run build` (or `wxt build`) succeeds
3. Verify `circuitBreakerManager` is imported and used in background.ts
4. Verify circuit breaker rehydration is in the init chain (after encryption, before store)
5. Verify `allowRequest()` checks exist before both LLM streamWithRetry calls and START_TRANSCRIPTION handler
6. Verify `recordSuccess()`/`recordFailure()` calls wrap around streamWithRetry at Promise level
7. Verify TRANSCRIPTION_ERROR records failure and TRANSCRIPTION_STARTED records success for elevenlabs breaker
  </verify>
  <done>
Circuit breaker is integrated into background.ts: LLM requests check circuit before calling streamWithRetry and record success/failure after; ElevenLabs checks circuit before START_TRANSCRIPTION and records via TRANSCRIPTION_STARTED/TRANSCRIPTION_ERROR messages; state changes broadcast to HealthIndicator via CONNECTION_STATE; rehydration runs during init chain before store is ready.
  </done>
</task>

</tasks>

<verification>
1. **Circuit OPEN after 3 failures:** Configure a non-existent API key. Make 3 LLM requests that fail. The 4th request should be immediately rejected with "service temporarily unavailable" without any network request.
2. **HealthIndicator shows error:** When circuit is OPEN, the overlay's HealthIndicator should show an error state for the affected service.
3. **Recovery via alarm:** After the recovery timeout (60s for LLM, 30s for ElevenLabs), the circuit should transition to HALF_OPEN (HealthIndicator shows "reconnecting").
4. **Service worker restart persistence:** Open circuit, kill service worker via chrome://serviceworker-internals, restart it. Circuit should still be OPEN (rehydrated from chrome.storage.session).
5. **Recovery to CLOSED:** In HALF_OPEN state, if the next request succeeds, circuit transitions to CLOSED and normal operation resumes.
6. **Per-provider isolation:** OpenAI circuit opening does not affect OpenRouter or ElevenLabs circuits.
7. **Build succeeds:** `wxt build` completes without errors.
</verification>

<success_criteria>
- CircuitBreaker class implements CLOSED/OPEN/HALF_OPEN state machine with chrome.storage.session persistence
- chrome.alarms used for OPEN-to-HALF_OPEN recovery timeout (not setTimeout)
- Per-provider circuit breakers: openai, openrouter, elevenlabs
- Circuit breaker wraps AROUND streamWithRetry (not inside retries)
- ElevenLabs circuit breaker at background level (START_TRANSCRIPTION handler)
- State changes broadcast via CONNECTION_STATE to existing HealthIndicator
- Circuit breaker rehydration in background.ts init chain (after encryption, before store)
- alarms permission added to manifest
- TypeScript strict mode passes
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/12-circuit-breaker/12-01-SUMMARY.md`
</output>
