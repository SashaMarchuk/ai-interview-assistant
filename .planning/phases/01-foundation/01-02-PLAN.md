---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/types/messages.ts
  - src/entrypoints/background.ts
  - src/entrypoints/popup/main.tsx
  - src/entrypoints/popup/App.tsx
  - src/entrypoints/offscreen/index.html
  - src/entrypoints/offscreen/index.ts
  - src/entrypoints/content.tsx
  - src/components/OverlayPlaceholder.tsx
autonomous: true

must_haves:
  truths:
    - "Popup shows UI when clicking extension icon"
    - "Popup can ping Service Worker and get response"
    - "Service Worker can create Offscreen Document"
    - "Offscreen Document communicates with Service Worker"
    - "Content Script injects placeholder UI on Google Meet"
  artifacts:
    - path: "src/types/messages.ts"
      provides: "Typed message interfaces"
      exports: ["ExtensionMessage", "isMessage"]
    - path: "src/entrypoints/background.ts"
      provides: "Service Worker with message handling"
      contains: "chrome.runtime.onMessage.addListener"
    - path: "src/entrypoints/popup/App.tsx"
      provides: "Popup UI with ping test"
      contains: "chrome.runtime.sendMessage"
    - path: "src/entrypoints/offscreen/index.ts"
      provides: "Offscreen document script"
      contains: "chrome.runtime.onMessage.addListener"
    - path: "src/entrypoints/content.tsx"
      provides: "Content script with overlay injection"
      contains: "attachShadow"
  key_links:
    - from: "src/entrypoints/popup/App.tsx"
      to: "src/entrypoints/background.ts"
      via: "chrome.runtime.sendMessage"
      pattern: "sendMessage.*PING"
    - from: "src/entrypoints/background.ts"
      to: "src/entrypoints/offscreen/index.ts"
      via: "chrome.offscreen.createDocument"
      pattern: "createDocument"
    - from: "src/entrypoints/content.tsx"
      to: "src/entrypoints/background.ts"
      via: "chrome.runtime.sendMessage"
      pattern: "sendMessage"
---

<objective>
Implement all extension components with working message passing between Service Worker, Popup, Offscreen Document, and Content Script.

Purpose: Establish the communication infrastructure that all future phases build upon.
Output: Fully wired extension components that can exchange typed messages.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed message interfaces</name>
  <files>
    src/types/messages.ts
  </files>
  <action>
    Create src/types/messages.ts with discriminated union message types:

    ```typescript
    // Message types as discriminated union
    export type MessageType =
      | 'PING'
      | 'PONG'
      | 'CREATE_OFFSCREEN'
      | 'OFFSCREEN_READY'
      | 'INJECT_UI'
      | 'UI_INJECTED';

    // Base message interface
    interface BaseMessage {
      type: MessageType;
    }

    // Specific message interfaces
    export interface PingMessage extends BaseMessage {
      type: 'PING';
      timestamp: number;
    }

    export interface PongMessage extends BaseMessage {
      type: 'PONG';
      timestamp: number;
      receivedAt: number;
    }

    export interface CreateOffscreenMessage extends BaseMessage {
      type: 'CREATE_OFFSCREEN';
    }

    export interface OffscreenReadyMessage extends BaseMessage {
      type: 'OFFSCREEN_READY';
    }

    export interface InjectUIMessage extends BaseMessage {
      type: 'INJECT_UI';
    }

    export interface UIInjectedMessage extends BaseMessage {
      type: 'UI_INJECTED';
      success: boolean;
    }

    // Union type for all messages
    export type ExtensionMessage =
      | PingMessage
      | PongMessage
      | CreateOffscreenMessage
      | OffscreenReadyMessage
      | InjectUIMessage
      | UIInjectedMessage;

    // Type guard for message checking
    export function isMessage<T extends ExtensionMessage>(
      message: unknown,
      type: T['type']
    ): message is T {
      return (
        typeof message === 'object' &&
        message !== null &&
        'type' in message &&
        (message as { type: unknown }).type === type
      );
    }
    ```

    Ensure the path alias @/ is configured in tsconfig.json to resolve to ./src/.
  </action>
  <verify>
    `npx tsc --noEmit` compiles without errors.
    Import statement `import { ExtensionMessage } from '@/types/messages'` resolves.
  </verify>
  <done>
    Message types defined and exported.
    Type guard function works for discriminated union.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Service Worker with message handling</name>
  <files>
    src/entrypoints/background.ts
  </files>
  <action>
    Create/update src/entrypoints/background.ts following the pattern from research:

    CRITICAL: Register ALL event listeners synchronously at top level, not inside async functions.

    ```typescript
    import type { ExtensionMessage, PingMessage, PongMessage } from '@/types/messages';
    import { isMessage } from '@/types/messages';

    // Register message listener synchronously at top level - CRITICAL
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      handleMessage(message, sender)
        .then(sendResponse)
        .catch((error) => {
          console.error('Message handling error:', error);
          sendResponse({ error: error.message });
        });
      return true; // Keep channel open for async response
    });

    // Register install listener at top level
    chrome.runtime.onInstalled.addListener((details) => {
      console.log(`Extension ${details.reason}:`, details.previousVersion || 'fresh install');
    });

    // Async message handler
    async function handleMessage(
      message: ExtensionMessage,
      sender: chrome.runtime.MessageSender
    ): Promise<unknown> {
      console.log('Background received:', message.type, 'from:', sender.id);

      if (isMessage<PingMessage>(message, 'PING')) {
        return {
          type: 'PONG',
          timestamp: message.timestamp,
          receivedAt: Date.now(),
        } satisfies PongMessage;
      }

      if (isMessage(message, 'CREATE_OFFSCREEN')) {
        await ensureOffscreenDocument();
        return { type: 'OFFSCREEN_READY' };
      }

      if (isMessage(message, 'OFFSCREEN_READY')) {
        console.log('Offscreen document is ready');
        return { received: true };
      }

      console.warn('Unknown message type:', message);
      return { error: 'Unknown message type' };
    }

    // Offscreen document management
    let creatingOffscreen: Promise<void> | null = null;

    async function ensureOffscreenDocument(): Promise<void> {
      const offscreenUrl = chrome.runtime.getURL('offscreen.html');

      // Check if already exists (Chrome 116+)
      const existingContexts = await chrome.runtime.getContexts({
        contextTypes: ['OFFSCREEN_DOCUMENT'],
        documentUrls: [offscreenUrl],
      });

      if (existingContexts.length > 0) {
        console.log('Offscreen document already exists');
        return;
      }

      // Prevent race condition
      if (creatingOffscreen) {
        await creatingOffscreen;
        return;
      }

      console.log('Creating offscreen document...');
      creatingOffscreen = chrome.offscreen.createDocument({
        url: offscreenUrl,
        reasons: [chrome.offscreen.Reason.USER_MEDIA],
        justification: 'Audio capture and WebSocket for transcription',
      });

      await creatingOffscreen;
      creatingOffscreen = null;
      console.log('Offscreen document created');
    }

    // WXT export
    export default defineBackground(() => {
      console.log('AI Interview Assistant: Service Worker started');
    });
    ```

    Note: WXT uses defineBackground wrapper. The URL for offscreen is just 'offscreen.html' (WXT build output path).
  </action>
  <verify>
    `npm run build` compiles background.ts without errors.
    Service Worker console shows "Service Worker started" on extension load.
  </verify>
  <done>
    Service Worker handles PING/PONG messages.
    Offscreen document creation works with race condition protection.
    Event listeners registered synchronously.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Popup with connection test</name>
  <files>
    src/entrypoints/popup/main.tsx
    src/entrypoints/popup/App.tsx
  </files>
  <action>
    Update src/entrypoints/popup/main.tsx (should exist from WXT template):
    ```typescript
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import '@/assets/app.css';
    import App from './App';

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );
    ```

    Create/update src/entrypoints/popup/App.tsx:
    ```typescript
    import { useState } from 'react';
    import type { PongMessage, OffscreenReadyMessage } from '@/types/messages';

    function App() {
      const [status, setStatus] = useState<string>('Ready');
      const [pingResult, setPingResult] = useState<string | null>(null);
      const [offscreenStatus, setOffscreenStatus] = useState<string>('Not created');

      const handlePing = async () => {
        setStatus('Pinging...');
        try {
          const response = await chrome.runtime.sendMessage({
            type: 'PING',
            timestamp: Date.now(),
          }) as PongMessage;

          const roundTrip = response.receivedAt - response.timestamp;
          setPingResult(`Round trip: ${roundTrip}ms`);
          setStatus('Connected');
        } catch (error) {
          setStatus('Error');
          setPingResult(error instanceof Error ? error.message : 'Unknown error');
        }
      };

      const handleCreateOffscreen = async () => {
        setOffscreenStatus('Creating...');
        try {
          const response = await chrome.runtime.sendMessage({
            type: 'CREATE_OFFSCREEN',
          }) as OffscreenReadyMessage;

          if (response.type === 'OFFSCREEN_READY') {
            setOffscreenStatus('Created successfully');
          }
        } catch (error) {
          setOffscreenStatus(error instanceof Error ? error.message : 'Error');
        }
      };

      return (
        <div className="w-80 p-4 bg-white">
          <h1 className="text-lg font-bold mb-4 text-gray-900">
            AI Interview Assistant
          </h1>

          <div className="space-y-4">
            {/* Service Worker Test */}
            <div className="border rounded p-3">
              <h2 className="font-medium text-gray-700 mb-2">Service Worker</h2>
              <div className="text-sm text-gray-600 mb-2">Status: {status}</div>
              <button
                onClick={handlePing}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 text-sm"
              >
                Test Connection
              </button>
              {pingResult && (
                <div className="mt-2 text-sm text-gray-600">{pingResult}</div>
              )}
            </div>

            {/* Offscreen Document Test */}
            <div className="border rounded p-3">
              <h2 className="font-medium text-gray-700 mb-2">Offscreen Document</h2>
              <div className="text-sm text-gray-600 mb-2">Status: {offscreenStatus}</div>
              <button
                onClick={handleCreateOffscreen}
                className="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 text-sm"
              >
                Create Offscreen
              </button>
            </div>
          </div>

          <div className="mt-4 text-xs text-gray-400">
            v0.1.0 - Phase 1 Foundation
          </div>
        </div>
      );
    }

    export default App;
    ```

    Ensure the popup has proper HTML template (should exist from WXT):
    src/entrypoints/popup/index.html with a div#root.
  </action>
  <verify>
    Click extension icon - popup appears with UI.
    Click "Test Connection" - status changes to "Connected" with round trip time.
    Click "Create Offscreen" - status shows "Created successfully".
  </verify>
  <done>
    Popup renders with Tailwind styles.
    Popup successfully pings Service Worker.
    Popup can trigger Offscreen Document creation.
  </done>
</task>

</tasks>

<verification>
1. Popup shows styled UI when clicking extension icon
2. "Test Connection" button returns round trip time < 100ms
3. "Create Offscreen" button creates offscreen document without error
4. Service Worker console shows message handling logs
5. No TypeScript compilation errors
</verification>

<success_criteria>
- Message types compile and type guards work correctly
- Service Worker handles messages with proper async pattern
- Popup UI renders with Tailwind styles applied
- Popup-to-ServiceWorker communication works bidirectionally
- Offscreen Document can be created from Popup trigger
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
