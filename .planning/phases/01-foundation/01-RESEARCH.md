# Phase 1: Foundation - Research

**Researched:** 2026-01-29
**Domain:** Chrome MV3 Extension Architecture, Message Passing, Service Worker, Offscreen Document
**Confidence:** HIGH

## Summary

Phase 1 establishes the foundational Chrome MV3 extension architecture with working message passing between all components: Service Worker, Content Script, Offscreen Document, and Popup. This is pure infrastructure with no external API integrations yet.

The standard approach uses **WXT** (Web Extension Toolkit) as the build framework, which provides Vite-based development with excellent HMR support for Chrome extensions. The project will use React 18+ for UI components in the Popup and Content Script, TypeScript for type safety, and Tailwind CSS for styling.

Key architectural decision from prior research: WebSocket connections must live in the Offscreen Document (not Service Worker) due to the 30-second idle timeout that kills connections. This phase establishes that pattern even though no WebSocket is implemented yet.

**Primary recommendation:** Use WXT with React module, establish typed message passing interfaces early, and configure CSP for future WebSocket/API connections from the start.

## Standard Stack

The established libraries/tools for Chrome MV3 extension development:

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `wxt` | ^0.20.x | Chrome extension framework | Best 2025/2026 choice: active maintenance, superior HMR, smaller builds than Plasmo |
| `@wxt-dev/module-react` | latest | React integration for WXT | Official WXT module for React support |
| `react` | ^18.3.x | UI framework | Stable, excellent ecosystem, team familiarity |
| `react-dom` | ^18.3.x | React DOM bindings | Required with React |
| `typescript` | ^5.7.x | Type safety | Modern TypeScript with improved type inference |
| `@types/chrome` | latest | Chrome extension types | Official type definitions for chrome.* APIs |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `tailwindcss` | ^4.x | Utility-first CSS | All UI styling in Popup and Content Script |
| `@tailwindcss/vite` | ^4.x | Vite plugin for Tailwind v4 | Zero-config Tailwind integration |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| WXT | CRXJS Vite Plugin | CRXJS seeking maintainers, may archive June 2025; WXT has better HMR for Service Workers |
| WXT | Plasmo | Plasmo appears in maintenance mode, outdated Parcel bundler, 5x larger builds |
| React | Vue/Svelte | React has best ecosystem for this use case; prior research decided on React |

**Installation:**
```bash
npm create wxt@latest -- --template react
# or for existing project:
npm install wxt @wxt-dev/module-react react react-dom
npm install -D typescript @types/chrome tailwindcss @tailwindcss/vite
```

## Architecture Patterns

### Recommended Project Structure

```
src/
├── entrypoints/
│   ├── background.ts         # Service Worker entry
│   ├── content.tsx           # Content Script entry
│   ├── popup/
│   │   ├── main.tsx          # Popup entry
│   │   └── App.tsx           # Popup React component
│   └── offscreen/
│       ├── index.html        # Offscreen document HTML (required)
│       └── index.ts          # Offscreen document script
├── components/               # Shared React components
├── types/
│   └── messages.ts           # Typed message interfaces
├── utils/
│   └── messaging.ts          # Message passing utilities
└── assets/                   # Icons, static files
public/
└── icon/                     # Extension icons (16, 32, 48, 128)
wxt.config.ts                 # WXT configuration
manifest.json                 # (generated by WXT from config)
```

### Pattern 1: Service Worker Event Listeners

**What:** All event listeners must be registered synchronously at the top level of the service worker.
**When to use:** Always - this is required for Chrome MV3.
**Why:** Chrome may miss events if handlers aren't registered when the service worker wakes up.

```typescript
// src/entrypoints/background.ts
// Source: https://developer.chrome.com/docs/extensions/get-started/tutorial/service-worker-events

// CORRECT - Register synchronously at top level
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  handleMessage(message, sender, sendResponse);
  return true; // Keep channel open for async response
});

chrome.runtime.onInstalled.addListener((details) => {
  console.log('Extension installed:', details.reason);
});

// Async initialization can happen after
async function init() {
  const settings = await chrome.storage.local.get('settings');
  // ...
}
init();
```

### Pattern 2: Typed Message Passing

**What:** Define TypeScript interfaces for all messages between components.
**When to use:** Always - prevents runtime errors and improves maintainability.

```typescript
// src/types/messages.ts

// Message types as discriminated union
export type MessageType =
  | 'PING'
  | 'PONG'
  | 'CREATE_OFFSCREEN'
  | 'OFFSCREEN_READY'
  | 'INJECT_UI'
  | 'UI_INJECTED';

// Base message interface
interface BaseMessage {
  type: MessageType;
}

// Specific message interfaces
export interface PingMessage extends BaseMessage {
  type: 'PING';
  timestamp: number;
}

export interface PongMessage extends BaseMessage {
  type: 'PONG';
  timestamp: number;
  receivedAt: number;
}

export interface CreateOffscreenMessage extends BaseMessage {
  type: 'CREATE_OFFSCREEN';
}

export interface OffscreenReadyMessage extends BaseMessage {
  type: 'OFFSCREEN_READY';
}

// Union type for all messages
export type ExtensionMessage =
  | PingMessage
  | PongMessage
  | CreateOffscreenMessage
  | OffscreenReadyMessage;

// Type-safe message handler
export function isMessage<T extends ExtensionMessage>(
  message: unknown,
  type: T['type']
): message is T {
  return (
    typeof message === 'object' &&
    message !== null &&
    'type' in message &&
    message.type === type
  );
}
```

### Pattern 3: Offscreen Document Lifecycle

**What:** Ensure only one offscreen document exists, check before creating.
**When to use:** Whenever using offscreen documents.

```typescript
// src/entrypoints/background.ts
// Source: https://developer.chrome.com/docs/extensions/reference/api/offscreen

let creatingOffscreen: Promise<void> | null = null;

async function ensureOffscreenDocument(): Promise<void> {
  const offscreenUrl = chrome.runtime.getURL('entrypoints/offscreen/index.html');

  // Check if already exists (Chrome 116+)
  const existingContexts = await chrome.runtime.getContexts({
    contextTypes: ['OFFSCREEN_DOCUMENT'],
    documentUrls: [offscreenUrl],
  });

  if (existingContexts.length > 0) {
    return; // Already exists
  }

  // Prevent race condition if multiple calls happen
  if (creatingOffscreen) {
    await creatingOffscreen;
    return;
  }

  creatingOffscreen = chrome.offscreen.createDocument({
    url: offscreenUrl,
    reasons: [chrome.offscreen.Reason.USER_MEDIA],
    justification: 'Audio capture and WebSocket for transcription',
  });

  await creatingOffscreen;
  creatingOffscreen = null;
}
```

### Pattern 4: Content Script Message Passing to Service Worker

**What:** Content scripts use `chrome.runtime.sendMessage` to communicate with service worker.
**When to use:** Any time content script needs to communicate with background.

```typescript
// src/entrypoints/content.tsx
// Source: https://developer.chrome.com/docs/extensions/develop/concepts/messaging

async function sendToBackground<T>(message: ExtensionMessage): Promise<T> {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage(message, (response) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
        return;
      }
      resolve(response as T);
    });
  });
}

// Example usage
async function pingBackground(): Promise<void> {
  const response = await sendToBackground<PongMessage>({
    type: 'PING',
    timestamp: Date.now(),
  });
  console.log('Round trip time:', response.receivedAt - response.timestamp, 'ms');
}
```

### Pattern 5: Service Worker to Content Script Communication

**What:** Service worker uses `chrome.tabs.sendMessage` to communicate with content scripts.
**When to use:** When service worker needs to push data to content script.

```typescript
// src/entrypoints/background.ts
// Source: https://developer.chrome.com/docs/extensions/develop/concepts/messaging

async function sendToContentScript<T>(
  tabId: number,
  message: ExtensionMessage
): Promise<T> {
  return chrome.tabs.sendMessage(tabId, message);
}

// Example: Send to all tabs matching a pattern
async function broadcastToMeetTabs(message: ExtensionMessage): Promise<void> {
  const tabs = await chrome.tabs.query({ url: 'https://meet.google.com/*' });

  for (const tab of tabs) {
    if (tab.id) {
      try {
        await sendToContentScript(tab.id, message);
      } catch (e) {
        // Tab may not have content script injected yet
        console.warn(`Failed to send to tab ${tab.id}:`, e);
      }
    }
  }
}
```

### Anti-Patterns to Avoid

- **Async event registration:** Never register chrome.* event listeners inside async callbacks or after await statements. Chrome may miss events.
- **Global state reliance:** Never rely on global variables persisting in service worker. Use `chrome.storage.session` for ephemeral state.
- **Missing `return true`:** Always return `true` from message listeners that respond asynchronously, or the channel closes before response arrives.
- **Unchecked `lastError`:** Always check `chrome.runtime.lastError` in callbacks to avoid uncaught errors.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Extension build tooling | Webpack/Rollup config | WXT | HMR, manifest generation, content script bundling are hard to get right |
| Message serialization | Custom protocol | JSON + typed interfaces | Chrome already uses JSON serialization; add types on top |
| Offscreen document detection | Manual tracking | `chrome.runtime.getContexts()` | Built-in API (Chrome 116+), handles edge cases |
| CSS isolation in content script | CSS modules | Shadow DOM | CSS modules don't prevent host page CSS bleeding in |
| Service worker persistence | Keep-alive hacks | Accept ephemeral nature | Chrome specifically designed SW to be ephemeral; design around it |

**Key insight:** Chrome's extension APIs are designed for specific patterns. Fighting them (like trying to keep service workers alive indefinitely) leads to fragile code. Embrace the ephemeral service worker model and use offscreen documents for persistent connections.

## Common Pitfalls

### Pitfall 1: Async Event Listener Registration

**What goes wrong:** Events registered inside async callbacks may not be handled.
**Why it happens:** Chrome evaluates top-level code when waking service worker; async code runs after.
**How to avoid:** Register ALL event listeners synchronously at the module's top level.
**Warning signs:** "Events work sometimes but not always" or "first message after wake works, subsequent don't."

### Pitfall 2: CSP Blocking External Connections

**What goes wrong:** WebSocket/fetch to external APIs fails silently or with CSP errors.
**Why it happens:** Default MV3 CSP doesn't allow external connections.
**How to avoid:** Configure `connect-src` in manifest CSP to allow required domains.
**Warning signs:** "Content Security Policy: blocked loading of resource" in console.

### Pitfall 3: Missing Offscreen Document Check

**What goes wrong:** Multiple offscreen documents attempted, causing errors.
**Why it happens:** Only one offscreen document allowed per extension.
**How to avoid:** Always check `chrome.runtime.getContexts()` before creating.
**Warning signs:** "Cannot create offscreen document" errors.

### Pitfall 4: DevTools Masks Service Worker Issues

**What goes wrong:** Extension works with DevTools open, breaks in production.
**Why it happens:** DevTools keeps service worker alive, preventing termination.
**How to avoid:** Test explicitly with DevTools closed; test on fresh Chrome profile.
**Warning signs:** "Works on my machine" syndrome.

### Pitfall 5: Content Script Isolation Confusion

**What goes wrong:** Content script can't access page variables, or vice versa.
**Why it happens:** Content scripts run in "isolated world" - separate JS context from page.
**How to avoid:** Understand that only DOM is shared. Use `chrome.scripting.executeScript` with `world: 'MAIN'` only if you explicitly need page context access.
**Warning signs:** "undefined" errors when accessing page globals.

## Code Examples

Verified patterns for Phase 1 implementation:

### Manifest Configuration (via WXT)

```typescript
// wxt.config.ts
// Source: https://wxt.dev/guide/essentials/config.html

import { defineConfig } from 'wxt';

export default defineConfig({
  modules: ['@wxt-dev/module-react'],
  manifest: {
    name: 'AI Interview Assistant',
    version: '0.1.0',
    description: 'Real-time transcription and AI assistance for interviews',
    permissions: [
      'tabCapture',
      'activeTab',
      'offscreen',
      'storage',
      'scripting',
    ],
    host_permissions: [
      'https://meet.google.com/*',
      // Add other meeting platforms as needed
    ],
    content_security_policy: {
      extension_pages: "script-src 'self' 'wasm-unsafe-eval'; object-src 'self'; connect-src 'self' wss://api.elevenlabs.io https://openrouter.ai https://*.openrouter.ai;",
    },
    minimum_chrome_version: '116',
  },
});
```

### Service Worker Setup

```typescript
// src/entrypoints/background.ts
import type { ExtensionMessage, PingMessage, PongMessage } from '@/types/messages';
import { isMessage } from '@/types/messages';

// Register message listener synchronously at top level
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // Handle messages asynchronously but return true synchronously
  handleMessage(message, sender)
    .then(sendResponse)
    .catch((error) => {
      console.error('Message handling error:', error);
      sendResponse({ error: error.message });
    });
  return true; // Keep channel open for async response
});

// Register install/update listener
chrome.runtime.onInstalled.addListener((details) => {
  console.log(`Extension ${details.reason}:`, details.previousVersion || 'fresh install');
});

// Async message handler
async function handleMessage(
  message: ExtensionMessage,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  if (isMessage<PingMessage>(message, 'PING')) {
    return {
      type: 'PONG',
      timestamp: message.timestamp,
      receivedAt: Date.now(),
    } satisfies PongMessage;
  }

  if (isMessage(message, 'CREATE_OFFSCREEN')) {
    await ensureOffscreenDocument();
    return { type: 'OFFSCREEN_READY' };
  }

  console.warn('Unknown message type:', message);
  return { error: 'Unknown message type' };
}

// Offscreen document management
let creatingOffscreen: Promise<void> | null = null;

async function ensureOffscreenDocument(): Promise<void> {
  const offscreenUrl = chrome.runtime.getURL('entrypoints/offscreen/index.html');

  const existingContexts = await chrome.runtime.getContexts({
    contextTypes: ['OFFSCREEN_DOCUMENT'],
    documentUrls: [offscreenUrl],
  });

  if (existingContexts.length > 0) {
    return;
  }

  if (creatingOffscreen) {
    await creatingOffscreen;
    return;
  }

  creatingOffscreen = chrome.offscreen.createDocument({
    url: offscreenUrl,
    reasons: [chrome.offscreen.Reason.USER_MEDIA],
    justification: 'Audio capture and WebSocket for transcription',
  });

  await creatingOffscreen;
  creatingOffscreen = null;
}

export default defineBackground(() => {
  console.log('Service Worker started');
});
```

### Popup Component

```typescript
// src/entrypoints/popup/App.tsx
import { useState } from 'react';
import type { PongMessage } from '@/types/messages';

export function App() {
  const [status, setStatus] = useState<string>('Ready');
  const [pingResult, setPingResult] = useState<string | null>(null);

  const handlePing = async () => {
    setStatus('Pinging...');
    try {
      const response = await chrome.runtime.sendMessage({
        type: 'PING',
        timestamp: Date.now(),
      }) as PongMessage;

      const roundTrip = response.receivedAt - response.timestamp;
      setPingResult(`Round trip: ${roundTrip}ms`);
      setStatus('Connected');
    } catch (error) {
      setStatus('Error');
      setPingResult(error instanceof Error ? error.message : 'Unknown error');
    }
  };

  return (
    <div className="w-80 p-4">
      <h1 className="text-lg font-bold mb-4">AI Interview Assistant</h1>
      <div className="mb-2">Status: {status}</div>
      <button
        onClick={handlePing}
        className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
      >
        Test Connection
      </button>
      {pingResult && (
        <div className="mt-2 text-sm text-gray-600">{pingResult}</div>
      )}
    </div>
  );
}
```

### Content Script with Placeholder UI

```typescript
// src/entrypoints/content.tsx
import { createRoot } from 'react-dom/client';
import { OverlayPlaceholder } from '@/components/OverlayPlaceholder';

// Only inject on Google Meet pages
const MEET_URL_PATTERN = /^https:\/\/meet\.google\.com\/.+/;

export default defineContentScript({
  matches: ['https://meet.google.com/*'],
  runAt: 'document_idle',
  main() {
    if (!MEET_URL_PATTERN.test(window.location.href)) {
      return; // Not an active meeting page
    }

    console.log('AI Interview Assistant: Content script loaded');
    injectOverlay();
  },
});

function injectOverlay(): void {
  // Create container in Shadow DOM for style isolation
  const container = document.createElement('div');
  container.id = 'ai-interview-assistant-root';

  const shadow = container.attachShadow({ mode: 'closed' });

  // Create style element for Tailwind (will be injected by WXT build)
  const styleSheet = document.createElement('style');
  // WXT will handle injecting the actual styles
  shadow.appendChild(styleSheet);

  // Create React root
  const reactRoot = document.createElement('div');
  reactRoot.id = 'react-root';
  shadow.appendChild(reactRoot);

  document.body.appendChild(container);

  // Render React component
  const root = createRoot(reactRoot);
  root.render(<OverlayPlaceholder />);

  console.log('AI Interview Assistant: Overlay injected');
}
```

### Offscreen Document

```html
<!-- src/entrypoints/offscreen/index.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>AI Interview Assistant - Offscreen</title>
</head>
<body>
  <script src="./index.ts" type="module"></script>
</body>
</html>
```

```typescript
// src/entrypoints/offscreen/index.ts
import type { ExtensionMessage } from '@/types/messages';
import { isMessage } from '@/types/messages';

// Listen for messages from service worker
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  handleMessage(message, sender)
    .then(sendResponse)
    .catch((error) => {
      console.error('Offscreen message error:', error);
      sendResponse({ error: error.message });
    });
  return true;
});

async function handleMessage(
  message: ExtensionMessage,
  sender: chrome.runtime.MessageSender
): Promise<unknown> {
  console.log('Offscreen received message:', message);

  // Phase 1: Just acknowledge messages
  // Future phases will add WebSocket handling here

  return { received: true, type: message.type };
}

// Notify service worker that offscreen is ready
chrome.runtime.sendMessage({ type: 'OFFSCREEN_READY' });

console.log('Offscreen document initialized');
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manifest V2 background pages | MV3 Service Workers | Chrome 88 (Jan 2021), enforced 2024 | Must design for ephemeral workers |
| ScriptProcessorNode for audio | AudioWorklet | 2018 onwards | Lower latency, off-main-thread processing |
| chrome.extension.* APIs | chrome.runtime.* APIs | MV3 transition | Use runtime.* for messaging |
| Manual CSP configuration | WXT handles it | WXT adoption | Build tool manages CSP |
| Check `chrome.offscreen.hasDocument()` | Use `chrome.runtime.getContexts()` | Chrome 116 | More reliable offscreen detection |

**Deprecated/outdated:**
- **Manifest V2:** MV2 extensions no longer accepted in Chrome Web Store; all new extensions must use MV3
- **Background pages:** Replaced by Service Workers with ephemeral lifecycle
- **`chrome.extension.getBackgroundPage()`:** No longer works in MV3; use messaging instead
- **CRXJS Vite Plugin:** Project seeking maintainers, may archive June 2025; prefer WXT

## Open Questions

Things that couldn't be fully resolved:

1. **WXT Tailwind v4 integration specifics**
   - What we know: WXT supports Vite plugins; Tailwind v4 has Vite plugin
   - What's unclear: Exact configuration for Shadow DOM style injection
   - Recommendation: Start with standard setup; adjust if styles don't inject into shadow root. WXT handles content script CSS automatically.

2. **React 19 vs 18 for Chrome Extension**
   - What we know: Prior research mentions React 19.2.3; current stable is 18.3.x
   - What's unclear: Whether React 19 has any extension-specific gotchas
   - Recommendation: Use React 18.3.x (stable, well-tested with extensions); upgrade to 19 after v1 if needed.

## Sources

### Primary (HIGH confidence)
- [Chrome Extension Service Workers](https://developer.chrome.com/docs/extensions/develop/concepts/service-workers) - Service worker lifecycle, registration patterns
- [Chrome Offscreen Documents API](https://developer.chrome.com/docs/extensions/reference/api/offscreen) - Offscreen document creation, reasons, lifecycle
- [Chrome Message Passing](https://developer.chrome.com/docs/extensions/develop/concepts/messaging) - Messaging patterns, async responses
- [Chrome Content Scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts) - Isolated worlds, injection methods
- [Chrome CSP for Extensions](https://developer.chrome.com/docs/extensions/reference/manifest/content-security-policy) - connect-src for external connections
- [WXT Documentation](https://wxt.dev/) - Build configuration, React module

### Secondary (MEDIUM confidence)
- [WebSockets in Service Workers](https://developer.chrome.com/docs/extensions/how-to/web-platform/websockets) - Chrome 116+ WebSocket keepalive patterns
- [Extension Service Worker Lifecycle](https://developer.chrome.com/docs/extensions/develop/concepts/service-workers/lifecycle) - 30-second timeout, termination conditions

### Tertiary (LOW confidence)
- WebSearch results on WXT vs CRXJS comparison - confirmed by WXT docs and CRXJS GitHub status
- WebSearch results on project structure patterns - validated against WXT documentation

## Metadata

**Confidence breakdown:**
- Standard Stack: HIGH - WXT is well-documented, React/TypeScript are mature
- Architecture: HIGH - Chrome official docs provide clear patterns
- Pitfalls: HIGH - Prior project research documented pitfalls with sources

**Research date:** 2026-01-29
**Valid until:** 90 days (stable Chrome extension APIs, WXT actively maintained)
