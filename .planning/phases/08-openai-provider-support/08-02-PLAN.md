---
phase: 08-openai-provider-support
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/store/types.ts
  - src/store/settingsSlice.ts
  - src/components/settings/ApiKeySettings.tsx
  - src/components/settings/ModelSettings.tsx
autonomous: true

must_haves:
  truths:
    - "User can enter OpenAI API key in settings"
    - "OpenAI key persists across browser sessions"
    - "Model selection UI shows provider indicator"
  artifacts:
    - path: "src/store/types.ts"
      provides: "Updated ApiKeyProvider type with 'openAI'"
      contains: "'openAI'"
    - path: "src/store/settingsSlice.ts"
      provides: "OpenAI key in default settings and state"
      contains: "openAI:"
    - path: "src/components/settings/ApiKeySettings.tsx"
      provides: "OpenAI API key input field"
      contains: "openAI"
    - path: "src/components/settings/ModelSettings.tsx"
      provides: "Provider-aware model options via getAvailableModels"
      contains: "getAvailableModels"
  key_links:
    - from: "src/components/settings/ApiKeySettings.tsx"
      to: "src/store"
      via: "useStore hook"
      pattern: "useStore.*apiKeys"
    - from: "src/store/settingsSlice.ts"
      to: "chrome.storage"
      via: "chromeStorage adapter"
      pattern: "apiKeys.*openAI"
    - from: "src/components/settings/ModelSettings.tsx"
      to: "src/services/llm/providers"
      via: "getAvailableModels import and call"
      pattern: "import.*getAvailableModels.*llm"
---

<objective>
Update the store and settings UI to support OpenAI as an additional API key provider with provider-aware model selection.

Purpose: Enable users to configure OpenAI API keys and see appropriate models for their configured provider(s). This depends on Plan 01 for the provider layer (getAvailableModels, ModelInfo type).

Output: Updated store types, settings slice, and settings UI components wired to provider layer
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-openai-provider-support/08-RESEARCH.md

# Prior plan summary (dependency context)
@.planning/phases/08-openai-provider-support/08-01-SUMMARY.md

# Existing store and UI files to modify
@src/store/types.ts
@src/store/settingsSlice.ts
@src/components/settings/ApiKeySettings.tsx
@src/components/settings/ModelSettings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update store types and settings slice</name>
  <files>
    src/store/types.ts
    src/store/settingsSlice.ts
  </files>
  <action>
1. Update `src/store/types.ts`:

Change ApiKeyProvider type from:
```typescript
export type ApiKeyProvider = 'elevenLabs' | 'openRouter';
```
To:
```typescript
export type ApiKeyProvider = 'elevenLabs' | 'openRouter' | 'openAI';
```

Update SettingsSlice interface - change apiKeys from:
```typescript
apiKeys: {
  elevenLabs: string;
  openRouter: string;
};
```
To:
```typescript
apiKeys: {
  elevenLabs: string;
  openRouter: string;
  openAI: string;
};
```

2. Update `src/store/settingsSlice.ts`:

Update DEFAULT_SETTINGS.apiKeys from:
```typescript
apiKeys: {
  elevenLabs: '',
  openRouter: '',
},
```
To:
```typescript
apiKeys: {
  elevenLabs: '',
  openRouter: '',
  openAI: '',
},
```

The setApiKey action already handles dynamic provider keys via `[provider]: key`, so no action changes needed.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Verify store types show openAI in ApiKeyProvider union
  </verify>
  <done>
Store types and settings slice updated with openAI key support, chrome.storage persistence will handle the new field automatically
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ApiKeySettings and ModelSettings UI</name>
  <files>
    src/components/settings/ApiKeySettings.tsx
    src/components/settings/ModelSettings.tsx
  </files>
  <action>
1. Update `src/components/settings/ApiKeySettings.tsx`:

Add OpenAI to API_KEY_FIELDS array:
```typescript
const API_KEY_FIELDS: { provider: ApiKeyProvider; label: string; placeholder: string }[] = [
  {
    provider: 'elevenLabs',
    label: 'ElevenLabs API Key',
    placeholder: 'Enter your ElevenLabs API key',
  },
  {
    provider: 'openRouter',
    label: 'OpenRouter API Key',
    placeholder: 'Enter your OpenRouter API key',
  },
  {
    provider: 'openAI',
    label: 'OpenAI API Key',
    placeholder: 'Enter your OpenAI API key',
  },
];
```

Update showKey initial state to include openAI:
```typescript
const [showKey, setShowKey] = useState<Record<string, boolean>>({
  elevenLabs: false,
  openRouter: false,
  openAI: false,
});
```

2. Update `src/components/settings/ModelSettings.tsx`:

**IMPORTANT:** Do NOT duplicate model lists. Import from the provider layer created in Plan 01.

Add imports at the top:
```typescript
import { getAvailableModels, type ModelInfo } from '../../services/llm';
```

Remove the hardcoded FAST_MODELS and FULL_MODELS arrays entirely.

Update ModelSelect component to use getAvailableModels dynamically:

```typescript
interface ModelSelectProps {
  label: string;
  description: string;
  modelType: ModelType;
  category: 'fast' | 'full';
}

function ModelSelect({ label, description, modelType, category }: ModelSelectProps) {
  const models = useStore((state) => state.models);
  const setModel = useStore((state) => state.setModel);
  const apiKeys = useStore((state) => state.apiKeys);

  // Get available models from provider layer based on configured API keys
  const allModels = getAvailableModels({
    openAI: apiKeys.openAI,
    openRouter: apiKeys.openRouter,
  });

  // Filter by category (fast/full)
  const availableOptions = allModels.filter((model) => model.category === category);

  // Group models by provider for optgroups
  const openaiModels = availableOptions.filter((m) => m.provider === 'openai');
  const openrouterModels = availableOptions.filter((m) => m.provider === 'openrouter');

  const currentValue = models[modelType];
  const isCurrentAvailable = availableOptions.some((m) => m.id === currentValue);

  return (
    <div>
      <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
      <select
        value={currentValue}
        onChange={(e) => setModel(modelType, e.target.value)}
        className={`w-full px-3 py-2 border rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
          !isCurrentAvailable && availableOptions.length > 0 ? 'border-yellow-400' : 'border-gray-300'
        }`}
      >
        {/* Show current value even if not available (grayed out) */}
        {!isCurrentAvailable && (
          <option value={currentValue} disabled className="text-gray-400">
            {currentValue} (requires API key)
          </option>
        )}
        {/* Group by provider */}
        {openaiModels.length > 0 && (
          <optgroup label="OpenAI">
            {openaiModels.map((model) => (
              <option key={model.id} value={model.id}>
                {model.name}
              </option>
            ))}
          </optgroup>
        )}
        {openrouterModels.length > 0 && (
          <optgroup label="OpenRouter">
            {openrouterModels.map((model) => (
              <option key={model.id} value={model.id}>
                {model.name}
              </option>
            ))}
          </optgroup>
        )}
      </select>
      <p className="mt-1 text-xs text-gray-500">{description}</p>
      {availableOptions.length === 0 && (
        <p className="mt-1 text-xs text-yellow-600">
          Configure an API key to enable model selection
        </p>
      )}
    </div>
  );
}
```

Update the ModelSettings component calls to pass category instead of options:
```typescript
export function ModelSettings() {
  return (
    <div className="space-y-4">
      <ModelSelect
        label="Fast Model"
        description="Used for quick hints - optimized for low latency"
        modelType="fastModel"
        category="fast"
      />
      <ModelSelect
        label="Full Model"
        description="Used for comprehensive answers - optimized for quality"
        modelType="fullModel"
        category="full"
      />
    </div>
  );
}
```

This approach:
- Single source of truth: Models defined in providers, not duplicated in UI
- Dynamic filtering: Only shows models for configured providers
- Type-safe: Uses ModelInfo type from provider layer
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors
Run `npm run build` - builds successfully
Manually verify: Load extension, open popup, Settings tab shows OpenAI API key field
Manually verify: Model dropdowns group models by provider with optgroup labels
  </verify>
  <done>
API key settings shows OpenAI field, model settings imports from provider layer and groups models by configured provider
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` completes successfully
3. ApiKeyProvider type includes 'openAI'
4. Settings slice has openAI in default apiKeys
5. ApiKeySettings.tsx shows three API key fields (ElevenLabs, OpenRouter, OpenAI)
6. ModelSettings.tsx imports getAvailableModels from provider layer (NOT hardcoded lists)
7. Model dropdowns use optgroup to separate providers
</verification>

<success_criteria>
- Store types updated with 'openAI' in ApiKeyProvider union
- Settings slice defaults include empty openAI key
- API key settings UI shows OpenAI field with show/hide toggle
- Model settings imports getAvailableModels() from providers (single source of truth)
- Model settings filters available models by configured provider
- Model dropdowns group options by provider (OpenAI / OpenRouter)
- Build succeeds with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-openai-provider-support/08-02-SUMMARY.md`
</output>
