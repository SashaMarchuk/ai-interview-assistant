---
phase: 09-security-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/messages.ts
  - entrypoints/popup/App.tsx
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "No API key value appears in any chrome.runtime message sent from popup to background"
    - "Background reads ElevenLabs API key from Zustand store, not from incoming message data"
    - "Messages arriving before store hydration are queued and processed after hydration completes"
    - "webext-zustand internal messages (chromex.dispatch, chromex.fetch_state) are never queued"
    - "Popup still shows immediate UX feedback when ElevenLabs key is missing"
    - "Internal background-to-offscreen message still carries the API key for ElevenLabs WebSocket auth"
  artifacts:
    - path: "src/types/messages.ts"
      provides: "StartTranscriptionMessage without apiKey, InternalStartTranscriptionMessage with apiKey"
      contains: "InternalStartTranscriptionMessage"
    - path: "entrypoints/popup/App.tsx"
      provides: "START_TRANSCRIPTION message without apiKey field"
    - path: "entrypoints/background.ts"
      provides: "Queue guard + store-based API key read for transcription"
      contains: "storeReady"
  key_links:
    - from: "entrypoints/popup/App.tsx"
      to: "entrypoints/background.ts"
      via: "chrome.runtime.sendMessage START_TRANSCRIPTION (no apiKey)"
      pattern: "type:\\s*'START_TRANSCRIPTION'"
    - from: "entrypoints/background.ts"
      to: "src/store/index.ts"
      via: "useStore.getState().apiKeys.elevenLabs"
      pattern: "useStore\\.getState\\(\\)"
    - from: "entrypoints/background.ts"
      to: "offscreen"
      via: "internal message with apiKey + _fromBackground"
      pattern: "_fromBackground:\\s*true"
---

<objective>
Remove API keys from popup-to-background chrome.runtime messages and add a queue guard to ensure the Zustand store is hydrated before processing any messages.

Purpose: API keys visible in DevTools message inspector are a security risk. Messages arriving before store hydration cause silent failures on service worker cold starts.

Output: Three modified files -- messages.ts (type change), App.tsx (remove apiKey from message), background.ts (queue guard + read key from store).
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-security-foundation/09-RESEARCH.md

@src/types/messages.ts
@entrypoints/popup/App.tsx
@entrypoints/background.ts
@src/store/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove apiKey from external StartTranscriptionMessage and update popup</name>
  <files>src/types/messages.ts, entrypoints/popup/App.tsx</files>
  <action>
**In `src/types/messages.ts`:**

1. Remove the `apiKey: string` field from `StartTranscriptionMessage` (line 173). Keep `languageCode`. The interface should become:
```typescript
export interface StartTranscriptionMessage extends BaseMessage {
  type: 'START_TRANSCRIPTION';
  /** ISO 639-3 language code (e.g. 'eng', 'ukr') - empty/undefined for auto-detect */
  languageCode?: string;
}
```

2. Add a new `InternalStartTranscriptionMessage` interface below `StartTranscriptionMessage` for the background-to-offscreen internal message:
```typescript
/** Internal message from background to offscreen -- carries API key within trusted extension origin */
export interface InternalStartTranscriptionMessage extends BaseMessage {
  type: 'START_TRANSCRIPTION';
  apiKey: string;
  languageCode?: string;
  _fromBackground: true;
}
```

This type is NOT added to the `ExtensionMessage` union -- it is only used for type-safe casting inside background.ts when forwarding to offscreen.

**In `entrypoints/popup/App.tsx`:**

1. In `handleStartTranscription()` (around line 292-296), remove the `apiKey: apiKeys.elevenLabs` field from the `chrome.runtime.sendMessage` call. The message should become:
```typescript
const response = await chrome.runtime.sendMessage({
  type: 'START_TRANSCRIPTION',
  languageCode: transcriptionLanguage || undefined,
} as ExtensionMessage);
```

2. Keep the existing `if (!apiKeys.elevenLabs)` check at lines 283-287. This is the UX boundary -- immediate feedback to the user. The background will also validate, serving as the security boundary.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Confirm `StartTranscriptionMessage` no longer has `apiKey`. Confirm `InternalStartTranscriptionMessage` exists with `apiKey` and `_fromBackground: true`. Confirm App.tsx no longer sends `apiKey` in START_TRANSCRIPTION message.
  </verify>
  <done>
`StartTranscriptionMessage` type has no `apiKey` field. `InternalStartTranscriptionMessage` type exists with `apiKey` + `_fromBackground: true`. Popup sends `START_TRANSCRIPTION` without `apiKey`. Popup still validates key presence for UX feedback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add queue guard and read ElevenLabs API key from store in background</name>
  <files>entrypoints/background.ts</files>
  <action>
**Part A: Queue guard for store hydration (REL-01)**

1. Add queue infrastructure BEFORE the `chrome.runtime.onMessage.addListener` call (after line 433). Add these module-level declarations:

```typescript
// Queue guard for store hydration -- messages arriving before store is ready are queued
interface QueuedMessage {
  message: ExtensionMessage;
  sender: chrome.runtime.MessageSender;
  sendResponse: (response: unknown) => void;
}
const messageQueue: QueuedMessage[] = [];
let storeReady = false;
```

2. Modify the existing `storeReadyPromise.then()` block (lines 125-127) to set the `storeReady` flag and drain the queue:

```typescript
storeReadyPromise.then(() => {
  storeReady = true;
  console.log('Store ready in service worker, draining', messageQueue.length, 'queued messages');
  for (const { message, sender, sendResponse } of messageQueue) {
    handleMessage(message, sender)
      .then(sendResponse)
      .catch((error) => {
        console.error('Queued message handling error:', error);
        sendResponse({ error: error.message });
      });
  }
  messageQueue.length = 0;
});
```

3. Add a 10-second timeout safety net. After the `storeReadyPromise.then()` block, add:

```typescript
// Safety net: if store fails to hydrate within 10 seconds, drain queue with errors
setTimeout(() => {
  if (!storeReady) {
    console.error('Store hydration timeout after 10 seconds -- draining queue with errors');
    storeReady = true; // Prevent further queuing
    for (const { sendResponse } of messageQueue) {
      sendResponse({ error: 'Store initialization timeout' });
    }
    messageQueue.length = 0;
  }
}, 10_000);
```

4. Modify the `chrome.runtime.onMessage.addListener` callback (lines 436-465) to add a queue guard check AFTER the three existing early-return filters (webext-zustand, _fromBackground, offscreenOnlyTypes) but BEFORE the `handleMessage` call:

```typescript
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 1. Ignore webext-zustand internal sync messages (MUST stay first -- prevents deadlock)
  if (message?.type === 'chromex.dispatch' || message?.type === 'chromex.fetch_state') {
    return false;
  }

  // 2. Messages with _fromBackground marker -- let offscreen handle
  if (message?._fromBackground === true) {
    console.log('Ignoring _fromBackground message:', message.type);
    return false;
  }

  // 3. Offscreen-only message types
  const offscreenOnlyTypes = ['TAB_STREAM_ID', 'START_MIC_CAPTURE', 'STOP_MIC_CAPTURE'];
  if (offscreenOnlyTypes.includes(message?.type) && sender.id === chrome.runtime.id) {
    console.log('Skipping offscreen-only message in background:', message.type);
    return false;
  }

  // 4. Queue guard: if store not ready, queue message for processing after hydration
  if (!storeReady) {
    console.log('Store not ready, queuing message:', message?.type);
    messageQueue.push({ message, sender, sendResponse });
    return true; // Keep channel open for async response
  }

  // 5. Normal message handling
  handleMessage(message, sender)
    .then(sendResponse)
    .catch((error) => {
      console.error('Message handling error:', error);
      sendResponse({ error: error.message });
    });
  return true;
});
```

**Part B: Read ElevenLabs API key from store (SEC-01)**

5. Import `InternalStartTranscriptionMessage` from messages.ts at the top of background.ts (add to existing import).

6. Modify the `START_TRANSCRIPTION` case in `handleMessage` (lines 699-725) to read the API key from the store instead of `message.apiKey`:

```typescript
case 'START_TRANSCRIPTION': {
  try {
    // Ensure offscreen document exists
    await ensureOffscreenDocument();

    // Clear transcript state for new session
    mergedTranscript = [];
    interimEntries.clear();

    // Read API key from store (SEC-01: never from message)
    const state = useStore.getState();
    const elevenLabsKey = state.apiKeys.elevenLabs;

    if (!elevenLabsKey) {
      return { success: false, error: 'ElevenLabs API key not configured' };
    }

    // Forward to offscreen document with API key from store (internal message)
    await chrome.runtime.sendMessage({
      type: 'START_TRANSCRIPTION',
      apiKey: elevenLabsKey,
      languageCode: message.languageCode,
      _fromBackground: true,
    } as InternalStartTranscriptionMessage);

    isTranscriptionActive = true;
    console.log('Transcription: Starting...');
    return { success: true };
  } catch (error) {
    isTranscriptionActive = false;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('Transcription start failed:', errorMessage);
    return { success: false, error: errorMessage };
  }
}
```

**Critical constraints:**
- The webext-zustand filter (step 1 in listener) MUST remain first. Queuing these messages causes deadlock.
- The `_fromBackground` and `offscreenOnlyTypes` filters MUST remain before the queue guard. These messages should never be queued.
- The offscreen document (`entrypoints/offscreen/main.ts`) is NOT modified. It still reads `message.apiKey` from the internal message.
- Do NOT add `InternalStartTranscriptionMessage` to the `ExtensionMessage` union type.
  </action>
  <verify>
1. Run `npx tsc --noEmit` -- no type errors.
2. Run `npm run build` (or `npx wxt build`) -- build succeeds with no errors.
3. Verify `storeReady` flag and `messageQueue` exist in background.ts.
4. Verify `handleMessage` for `START_TRANSCRIPTION` reads `useStore.getState().apiKeys.elevenLabs`.
5. Verify queue guard check is present in the listener, AFTER the three early-return filters.
6. Grep: `grep -n 'apiKey' entrypoints/popup/App.tsx` should NOT match any line in `handleStartTranscription`.
7. Grep: `grep -n 'message\.apiKey' entrypoints/background.ts` should return zero matches (background no longer reads apiKey from message).
  </verify>
  <done>
Queue guard queues messages until store hydrates, then drains. 10-second timeout prevents infinite hang. Background reads ElevenLabs key from `useStore.getState().apiKeys.elevenLabs`. Internal forward to offscreen uses `InternalStartTranscriptionMessage` with `apiKey` from store. `message.apiKey` is never read in background.ts. Build passes. No type errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` (or `npx wxt build`) succeeds
3. `grep -rn 'apiKey' entrypoints/popup/App.tsx` -- the only `apiKey` references should be in the store selector (`apiKeys`) and the UX validation check, NOT in any `sendMessage` call
4. `grep -rn 'message\.apiKey' entrypoints/background.ts` -- zero matches (background never reads apiKey from message)
5. `grep -n 'storeReady' entrypoints/background.ts` -- confirms queue guard flag exists
6. `grep -n 'messageQueue' entrypoints/background.ts` -- confirms queue infrastructure exists
7. `grep -n 'InternalStartTranscriptionMessage' src/types/messages.ts` -- confirms internal type exists
8. The `ExtensionMessage` union in messages.ts does NOT include `InternalStartTranscriptionMessage`
</verification>

<success_criteria>
- SEC-01: `StartTranscriptionMessage` has no `apiKey` field. Popup sends no API key in messages. Background reads key from store.
- REL-01: Queue guard ensures messages are held until store hydrates. webext-zustand messages bypass queue. 10-second timeout prevents hang.
- Build succeeds with zero type errors.
- No functional regression: transcription flow still works (background reads key from store, forwards to offscreen).
</success_criteria>

<output>
After completion, create `.planning/phases/09-security-foundation/09-01-SUMMARY.md`
</output>
