---
phase: 10-encryption-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/crypto/encryption.ts
  - src/services/crypto/encryptedStorage.ts
  - src/store/index.ts
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Inspecting chrome.storage.local via DevTools shows encrypted (base64) values for all API key fields, not plaintext"
    - "The extension functions normally after encryption migration -- all previously saved API keys still work for API calls"
    - "Restarting Chrome does not break decryption -- keys remain accessible to the extension"
    - "Encryption uses WebCrypto AES-GCM with PBKDF2 key derivation from chrome.runtime.id + stored salt"
    - "Non-sensitive store fields (models, blurLevel, templates, hotkeys) remain unencrypted and human-readable"
  artifacts:
    - path: "src/services/crypto/encryption.ts"
      provides: "EncryptionService singleton with AES-GCM encrypt/decrypt and PBKDF2 key derivation"
      exports: ["encryptionService"]
    - path: "src/services/crypto/encryptedStorage.ts"
      provides: "Encrypted StateStorage adapter wrapping chromeStorage"
      exports: ["encryptedChromeStorage"]
    - path: "src/store/index.ts"
      provides: "Store using encryptedChromeStorage instead of chromeStorage"
      contains: "encryptedChromeStorage"
    - path: "entrypoints/background.ts"
      provides: "Encryption initialization before store rehydration"
      contains: "encryptionService.initialize"
  key_links:
    - from: "src/services/crypto/encryptedStorage.ts"
      to: "src/services/crypto/encryption.ts"
      via: "import { encryptionService }"
      pattern: "encryptionService\\.encrypt|encryptionService\\.decrypt"
    - from: "src/store/index.ts"
      to: "src/services/crypto/encryptedStorage.ts"
      via: "import { encryptedChromeStorage }"
      pattern: "createJSONStorage.*encryptedChromeStorage"
    - from: "entrypoints/background.ts"
      to: "src/services/crypto/encryption.ts"
      via: "import { encryptionService }"
      pattern: "encryptionService\\.initialize"
    - from: "entrypoints/background.ts"
      to: "src/store/index.ts"
      via: "storeReadyPromise chained after encryption init"
      pattern: "encryptionService\\.initialize.*storeReadyPromise"
---

<objective>
Encrypt API keys at rest in chrome.storage.local using WebCrypto AES-GCM, with transparent migration from plaintext.

Purpose: API keys (elevenLabs, openRouter, openAI) are currently stored as plaintext in chrome.storage.local, readable by anyone with DevTools access. Encrypting them at rest raises the security bar significantly.

Output: EncryptionService singleton, encrypted storage adapter, and wired init chain. Zero consumer code changes -- all components continue using `useStore.getState().apiKeys` synchronously.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-encryption-layer/10-RESEARCH.md
@.planning/phases/09-security-foundation/09-01-SUMMARY.md
@src/store/index.ts
@src/store/chromeStorage.ts
@src/store/types.ts
@entrypoints/background.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EncryptionService and encrypted storage adapter</name>
  <files>
    src/services/crypto/encryption.ts
    src/services/crypto/encryptedStorage.ts
  </files>
  <action>
Create `src/services/crypto/encryption.ts` -- EncryptionService singleton class:

1. **Class structure:**
   - Private `key: CryptoKey | null = null`
   - Private `initPromise: Promise<void> | null = null` (dedup concurrent init calls)
   - Public `async initialize(): Promise<void>` -- idempotent, returns immediately if `key` exists, deduplicates via `initPromise`
   - Public `async encrypt(plaintext: string): Promise<string>` -- throws if not initialized
   - Public `async decrypt(ciphertext: string): Promise<string>` -- throws if not initialized
   - Public `get isInitialized(): boolean` -- returns `!!this.key`

2. **Key derivation in `_doInit()`:**
   - Get or create salt from `chrome.storage.local` key `_encryption_salt`
   - Salt is 16 bytes (`crypto.getRandomValues(new Uint8Array(16))`)
   - Store salt as `Array.from(salt)` (JSON-serializable form of Uint8Array)
   - Import `chrome.runtime.id` as PBKDF2 key material via `crypto.subtle.importKey('raw', encoder.encode(chrome.runtime.id), { name: 'PBKDF2' }, false, ['deriveKey'])`
   - Derive AES-GCM-256 key: `crypto.subtle.deriveKey({ name: 'PBKDF2', salt, iterations: 100_000, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt'])`
   - `false` = non-extractable. This is important.

3. **encrypt(plaintext):**
   - Generate 12-byte IV: `crypto.getRandomValues(new Uint8Array(12))`
   - Encrypt: `crypto.subtle.encrypt({ name: 'AES-GCM', iv }, this.key, new TextEncoder().encode(plaintext))`
   - Prepend IV to ciphertext: `combined = new Uint8Array(12 + ciphertext.byteLength)`, set iv at 0, ciphertext at 12
   - Return base64: `btoa(String.fromCharCode(...combined))`

4. **decrypt(ciphertext):**
   - Decode base64: `Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0))`
   - Extract IV (first 12 bytes) and data (rest)
   - Decrypt: `crypto.subtle.decrypt({ name: 'AES-GCM', iv }, this.key, data)`
   - Return: `new TextDecoder().decode(decrypted)`

5. Export singleton: `export const encryptionService = new EncryptionService();`

6. **Logging:** Log `'EncryptionService: initialized'` on successful init. Never log `chrome.runtime.id`, the salt, or any key material.

---

Create `src/services/crypto/encryptedStorage.ts` -- StateStorage adapter:

1. **Import** `StateStorage` from `zustand/middleware`, `chromeStorage` from `@/store/chromeStorage`, `encryptionService` from `./encryption`

2. **`getItem(name)`:**
   - Call `chromeStorage.getItem(name)` to get raw JSON string
   - If null, return null
   - Parse JSON. If `parsed.state?.apiKeys` exists, iterate each provider key:
     - Skip empty strings (`val.length === 0`)
     - If `encryptionService.isInitialized`, try `encryptionService.decrypt(value)`. On failure (DOMException from AES-GCM rejecting non-ciphertext), pass through as-is (plaintext fallback for migration)
     - If encryption service NOT initialized (non-background context importing store), pass through as-is
   - Return `JSON.stringify(parsed)` with decrypted apiKeys
   - Wrap entire body in try/catch, fallback to returning raw string

3. **`setItem(name, value)`:**
   - Parse JSON. If `parsed.state?.apiKeys` exists, iterate each provider key:
     - Skip empty strings (`val.length === 0`)
     - If `encryptionService.isInitialized`, encrypt the value
     - If NOT initialized, pass through as-is (non-background context)
   - Call `chromeStorage.setItem(name, JSON.stringify(parsed))`
   - Wrap in try/catch, fallback to `chromeStorage.setItem(name, value)` on failure

4. **`removeItem`:** Delegate directly to `chromeStorage.removeItem`

5. Export: `export const encryptedChromeStorage: StateStorage = { ... }`

**Key design decisions:**
- The `isInitialized` check enables graceful handling of popup/content script contexts that import `src/store/index.ts` but never initialize encryption. Only the background service worker initializes encryption.
- The try/catch on decrypt enables transparent migration: first read returns plaintext (fallback), first write encrypts. No explicit migration step.
- Empty strings are NOT encrypted (avoids unnecessary crypto for unconfigured keys).
  </action>
  <verify>
    - `npx tsc --noEmit` passes (may show pre-existing errors only)
    - `src/services/crypto/encryption.ts` exports `encryptionService` singleton
    - `src/services/crypto/encryptedStorage.ts` exports `encryptedChromeStorage` implementing `StateStorage`
    - Both files use only native WebCrypto APIs (no external dependencies)
  </verify>
  <done>
    EncryptionService class exists with initialize/encrypt/decrypt methods using AES-GCM-256 + PBKDF2. Encrypted storage adapter wraps chromeStorage with transparent encrypt-on-write and decrypt-on-read for apiKeys fields only, with plaintext fallback for migration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire encrypted adapter into store and init chain</name>
  <files>
    src/store/index.ts
    entrypoints/background.ts
  </files>
  <action>
**Modify `src/store/index.ts`:**

1. Replace the import of `chromeStorage`:
   - OLD: `import { chromeStorage } from './chromeStorage';`
   - NEW: `import { encryptedChromeStorage } from '../services/crypto/encryptedStorage';`

2. Replace the storage adapter reference in `createJSONStorage`:
   - OLD: `storage: createJSONStorage(() => chromeStorage),`
   - NEW: `storage: createJSONStorage(() => encryptedChromeStorage),`

3. Update the module JSDoc comment to mention encryption.

4. Do NOT change any other lines. The `chromeStorage` base adapter (`src/store/chromeStorage.ts`) remains unchanged -- `encryptedChromeStorage` composes on top of it.

---

**Modify `entrypoints/background.ts`:**

1. Add import at top (with other imports):
   ```typescript
   import { encryptionService } from '../src/services/crypto/encryption';
   ```

2. Find the existing store initialization block (currently lines 124-137):
   ```typescript
   import { storeReadyPromise } from '../src/store';
   storeReadyPromise.then(() => {
     storeReady = true;
     // ... drain queue ...
   });
   ```

3. Replace this block with an init chain that initializes encryption FIRST:
   ```typescript
   import { storeReadyPromise } from '../src/store';

   // Initialize encryption before store rehydration.
   // The encrypted storage adapter needs a valid CryptoKey to decrypt
   // persisted API keys during store rehydration.
   encryptionService.initialize()
     .then(() => storeReadyPromise)
     .then(() => {
       storeReady = true;
       console.log('Store ready in service worker, draining', messageQueue.length, 'queued messages');
       for (const { message, sender, sendResponse } of messageQueue) {
         handleMessage(message, sender)
           .then(sendResponse)
           .catch((error) => {
             console.error('Queued message handling error:', error);
             sendResponse({ error: error.message });
           });
       }
       messageQueue.length = 0;
     })
     .catch((error) => {
       console.error('Initialization failed:', error);
     });
   ```

4. The 10-second timeout safety net (lines 140-149) remains unchanged -- it already covers the case where store hydration fails, and now also covers encryption init failure.

5. Do NOT change the message listener, offscreen management, or any other part of background.ts.

**Critical ordering explanation:**
- `encryptionService.initialize()` runs first (~50-100ms) -- derives CryptoKey from `chrome.runtime.id` + salt
- `storeReadyPromise` runs second -- calls `wrapStore(useStore)` which triggers Zustand persist's `getItem()`, which now goes through `encryptedChromeStorage.getItem()`, which uses the already-initialized `encryptionService` to decrypt API keys
- Queue drain runs third -- by this point, both encryption and store are ready

**Important:** The `encryptedChromeStorage` adapter's `getItem` also has an internal `isInitialized` check. So even if timing is slightly off, it falls back to plaintext passthrough rather than crashing. But the explicit chaining in background.ts makes the ordering deterministic.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/store/index.ts` references `encryptedChromeStorage` (not `chromeStorage`)
    - `entrypoints/background.ts` calls `encryptionService.initialize()` before `storeReadyPromise`
    - `npm run build` succeeds (full extension build)
    - Load the built extension in Chrome, open popup, verify it loads without errors
    - Set an API key in settings, then inspect `chrome.storage.local` in DevTools Application tab -- the API key value should be a base64-encoded string, NOT the plaintext key
    - Reload the extension (not reinstall) -- the API key should still be accessible and functional
  </verify>
  <done>
    Store uses encrypted adapter. Background initializes encryption before store rehydration. API keys in chrome.storage.local are base64 AES-GCM ciphertext. Extension functions normally with encrypted storage. Reloading the extension does not break decryption.
  </done>
</task>

</tasks>

<verification>
1. **Build verification:** `npm run build` succeeds with zero errors
2. **Storage inspection:** Open DevTools > Application > Storage > chrome.storage.local. The `ai-interview-settings` key's JSON should show `apiKeys.elevenLabs`, `apiKeys.openRouter`, `apiKeys.openAI` as base64 strings (long, alphanumeric+/+=), NOT as plaintext `sk-...` values. Non-sensitive fields (models, blurLevel, templates) remain human-readable.
3. **Functional verification:** After encryption, the extension still works:
   - API keys saved in settings are readable when the settings page is re-opened
   - Transcription starts successfully (ElevenLabs key decrypts and connects)
   - LLM requests work (OpenAI/OpenRouter keys decrypt and authenticate)
4. **Restart verification:** Close and reopen Chrome entirely. Extension still works with the same API keys (no re-entry needed).
5. **Migration verification:** For first-time encryption, existing plaintext keys are automatically encrypted on next store write. No manual migration step.
6. **Salt persistence:** `chrome.storage.local` contains `_encryption_salt` as a number array (16 bytes).
</verification>

<success_criteria>
- SEC-02 satisfied: API keys encrypted at rest with AES-GCM + PBKDF2 from chrome.runtime.id + stored salt
- All 4 phase success criteria from ROADMAP.md are met
- Zero new dependencies added
- Zero consumer code changes (popup, content script, offscreen unchanged)
- Build passes, extension loads, API keys functional after encryption
</success_criteria>

<output>
After completion, create `.planning/phases/10-encryption-layer/10-01-SUMMARY.md`
</output>
