---
phase: 04-llm-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/hooks/useCaptureMode.ts
  - src/hooks/index.ts
  - entrypoints/content.tsx
autonomous: true

must_haves:
  truths:
    - "User can hold hotkey to capture and release to send"
    - "User can highlight transcript text and press hotkey to send"
    - "Visual indicator shows when capture mode is active"
    - "Captured text is sent to Service Worker via LLM_REQUEST"
  artifacts:
    - path: "src/hooks/useCaptureMode.ts"
      provides: "React hook for hotkey capture detection"
      exports: ["useCaptureMode"]
    - path: "src/hooks/index.ts"
      provides: "Barrel export for hooks"
  key_links:
    - from: "src/hooks/useCaptureMode.ts"
      to: "src/store"
      via: "useStore for hotkey binding"
      pattern: "useStore"
    - from: "entrypoints/content.tsx"
      to: "src/hooks/useCaptureMode"
      via: "import useCaptureMode"
      pattern: "useCaptureMode"
---

<objective>
Implement capture mode hook with hold-to-capture and highlight-to-send keyboard handling in the content script.

Purpose: Enable the primary user interaction - hold hotkey to capture question text, release to trigger LLM request.
Output: useCaptureMode hook and updated content script with keyboard listeners.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-llm-integration/04-RESEARCH.md
@entrypoints/content.tsx
@src/store/types.ts
@src/store/settingsSlice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useCaptureMode hook</name>
  <files>src/hooks/useCaptureMode.ts, src/hooks/index.ts</files>
  <action>
1. Create `src/hooks/useCaptureMode.ts`:

```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { useStore } from '../store';

export interface CaptureState {
  isHolding: boolean;
  captureStartTime: number | null;
  capturedText: string;
  mode: 'hold' | 'highlight';
}

interface UseCaptureOptions {
  /** Callback when capture is triggered (on key release for hold, on key press for highlight) */
  onCapture: (text: string, mode: 'hold' | 'highlight') => void;
  /** Function to get transcript entries since a timestamp */
  getTranscriptSince: (timestamp: number) => string;
  /** Function to get recent transcript (last N entries) */
  getRecentTranscript: () => string;
  /** Function to get full transcript */
  getFullTranscript: () => string;
}

/**
 * Parse hotkey string like "Ctrl+Shift+Space" into components
 */
function parseHotkey(hotkeyString: string): {
  key: string;
  ctrl: boolean;
  shift: boolean;
  alt: boolean;
  meta: boolean;
} {
  const parts = hotkeyString.split('+').map(p => p.toLowerCase().trim());
  const key = parts[parts.length - 1];
  return {
    key: key === 'space' ? ' ' : key,
    ctrl: parts.includes('ctrl') || parts.includes('control'),
    shift: parts.includes('shift'),
    alt: parts.includes('alt'),
    meta: parts.includes('meta') || parts.includes('cmd') || parts.includes('command'),
  };
}

/**
 * Check if keyboard event matches hotkey configuration
 */
function matchesHotkey(
  e: KeyboardEvent,
  hotkey: { key: string; ctrl: boolean; shift: boolean; alt: boolean; meta: boolean }
): boolean {
  const pressedKey = e.key.toLowerCase();
  const expectedKey = hotkey.key.toLowerCase();

  // Handle space specially
  const keyMatches = pressedKey === expectedKey ||
    (expectedKey === ' ' && pressedKey === ' ') ||
    (expectedKey === 'space' && pressedKey === ' ');

  return (
    keyMatches &&
    e.ctrlKey === hotkey.ctrl &&
    e.shiftKey === hotkey.shift &&
    e.altKey === hotkey.alt &&
    e.metaKey === hotkey.meta
  );
}

/**
 * Get currently highlighted/selected text
 */
function getHighlightedText(): string {
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0) return '';
  return selection.toString().trim();
}

/**
 * Hook for managing capture mode (hold-to-capture and highlight-to-send)
 */
export function useCaptureMode(options: UseCaptureOptions): CaptureState {
  const { onCapture, getTranscriptSince, getRecentTranscript, getFullTranscript } = options;

  // Get hotkey from store
  const captureHotkey = useStore((state) => state.hotkeys.capture);

  const [state, setState] = useState<CaptureState>({
    isHolding: false,
    captureStartTime: null,
    capturedText: '',
    mode: 'hold',
  });

  // Ref to track if we're currently holding (for keyup handler)
  const isHoldingRef = useRef(false);
  const captureStartTimeRef = useRef<number | null>(null);

  // Parse hotkey once when it changes
  const parsedHotkey = parseHotkey(captureHotkey);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (!matchesHotkey(e, parsedHotkey)) return;
    if (e.repeat) return; // Ignore key repeat

    e.preventDefault();
    e.stopPropagation();

    // Check for highlighted text first (highlight-to-send mode)
    const highlighted = getHighlightedText();
    if (highlighted) {
      // Clear selection
      window.getSelection()?.removeAllRanges();

      setState({
        isHolding: false,
        captureStartTime: null,
        capturedText: highlighted,
        mode: 'highlight',
      });

      // Trigger capture immediately for highlight mode
      onCapture(highlighted, 'highlight');
      return;
    }

    // Otherwise, start hold-to-capture mode
    const startTime = Date.now();
    isHoldingRef.current = true;
    captureStartTimeRef.current = startTime;

    setState({
      isHolding: true,
      captureStartTime: startTime,
      capturedText: '',
      mode: 'hold',
    });
  }, [parsedHotkey, onCapture]);

  const handleKeyUp = useCallback((e: KeyboardEvent) => {
    if (!matchesHotkey(e, parsedHotkey)) return;
    if (!isHoldingRef.current) return;

    e.preventDefault();
    e.stopPropagation();

    const startTime = captureStartTimeRef.current;
    isHoldingRef.current = false;
    captureStartTimeRef.current = null;

    // Get transcript text captured during hold
    const capturedText = startTime ? getTranscriptSince(startTime) : '';

    setState({
      isHolding: false,
      captureStartTime: null,
      capturedText,
      mode: 'hold',
    });

    // Trigger capture if we got text
    if (capturedText.trim()) {
      onCapture(capturedText, 'hold');
    }
  }, [parsedHotkey, onCapture, getTranscriptSince]);

  // Handle window blur (lost keyup)
  const handleBlur = useCallback(() => {
    if (isHoldingRef.current) {
      isHoldingRef.current = false;
      captureStartTimeRef.current = null;
      setState({
        isHolding: false,
        captureStartTime: null,
        capturedText: '',
        mode: 'hold',
      });
    }
  }, []);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown, true);
    window.addEventListener('keyup', handleKeyUp, true);
    window.addEventListener('blur', handleBlur);

    return () => {
      window.removeEventListener('keydown', handleKeyDown, true);
      window.removeEventListener('keyup', handleKeyUp, true);
      window.removeEventListener('blur', handleBlur);
    };
  }, [handleKeyDown, handleKeyUp, handleBlur]);

  return state;
}
```

2. Create `src/hooks/index.ts`:
```typescript
export { useCaptureMode, type CaptureState } from './useCaptureMode';
```
  </action>
  <verify>
   - `npx tsc --noEmit src/hooks/index.ts` passes
   - All exports resolve correctly
  </verify>
  <done>useCaptureMode hook handles hold-to-capture, highlight-to-send, and blur edge case</done>
</task>

<task type="auto">
  <name>Task 2: Integrate capture mode into content script</name>
  <files>entrypoints/content.tsx</files>
  <action>
Update entrypoints/content.tsx to use the capture mode hook and send LLM requests:

1. Add imports at top:
```typescript
import type { LLMRequestMessage } from '../src/types/messages';
```

2. Update module-level transcript state to track entries with timestamps:
```typescript
// Module-level transcript state
let currentTranscript: TranscriptEntry[] = [];

/**
 * Get transcript entries since a given timestamp, formatted as string
 */
function getTranscriptSince(timestamp: number): string {
  return currentTranscript
    .filter(e => e.timestamp >= timestamp && e.isFinal)
    .map(e => `${e.speaker}: ${e.text}`)
    .join('\n');
}

/**
 * Get recent transcript (last 5 final entries)
 */
function getRecentTranscript(): string {
  return currentTranscript
    .filter(e => e.isFinal)
    .slice(-5)
    .map(e => `${e.speaker}: ${e.text}`)
    .join('\n');
}

/**
 * Get full transcript formatted as string
 */
function getFullTranscript(): string {
  return currentTranscript
    .filter(e => e.isFinal)
    .map(e => `${e.speaker}: ${e.text}`)
    .join('\n');
}

/**
 * Send LLM request to background
 */
async function sendLLMRequest(question: string, mode: 'hold' | 'highlight'): Promise<void> {
  // Import store dynamically to get active template
  const { useStore } = await import('../src/store');
  const state = useStore.getState();

  if (!state.activeTemplateId) {
    console.warn('AI Interview Assistant: No active template selected');
    return;
  }

  const responseId = crypto.randomUUID();

  const message: LLMRequestMessage = {
    type: 'LLM_REQUEST',
    responseId,
    question,
    recentContext: getRecentTranscript(),
    fullTranscript: getFullTranscript(),
    templateId: state.activeTemplateId,
  };

  console.log('AI Interview Assistant: Sending LLM request', { mode, questionLength: question.length });

  try {
    const response = await chrome.runtime.sendMessage(message);
    if (!response?.success) {
      console.error('AI Interview Assistant: LLM request failed', response?.error);
    }
  } catch (error) {
    console.error('AI Interview Assistant: Failed to send LLM request', error);
  }
}
```

3. Create a wrapper component that uses the hook:

Inside the main() function, after the UI is mounted, we need a way to use the hook. Since we're rendering React, we'll create a wrapper component that contains the capture logic.

Create CaptureHandler component inside main():
```typescript
// Inside main() function, before createShadowRootUi

// Component to handle capture mode
function CaptureHandler() {
  const { useCaptureMode } = await import('../src/hooks');

  useCaptureMode({
    onCapture: (text, mode) => {
      sendLLMRequest(text, mode);
    },
    getTranscriptSince,
    getRecentTranscript,
    getFullTranscript,
  });

  return null; // No UI, just behavior
}
```

Actually, hooks can only be used inside React components. We need to modify the approach:

**Better approach:** Create a CaptureProvider component that wraps Overlay and uses the hook internally. Update the render to:

```typescript
// Inside onMount callback of createShadowRootUi
const root = createRoot(container);
root.render(
  <CaptureProvider
    onCapture={sendLLMRequest}
    getTranscriptSince={getTranscriptSince}
    getRecentTranscript={getRecentTranscript}
    getFullTranscript={getFullTranscript}
  >
    <Overlay />
  </CaptureProvider>
);
```

Create CaptureProvider as an inline component (above the defineContentScript):

```typescript
import { useCaptureMode, type CaptureState } from '../src/hooks';
import { createContext, useContext, type ReactNode } from 'react';

// Context to expose capture state to children
const CaptureContext = createContext<CaptureState | null>(null);

export function useCaptureState(): CaptureState | null {
  return useContext(CaptureContext);
}

interface CaptureProviderProps {
  children: ReactNode;
  onCapture: (text: string, mode: 'hold' | 'highlight') => void;
  getTranscriptSince: (timestamp: number) => string;
  getRecentTranscript: () => string;
  getFullTranscript: () => string;
}

function CaptureProvider({
  children,
  onCapture,
  getTranscriptSince,
  getRecentTranscript,
  getFullTranscript
}: CaptureProviderProps) {
  const captureState = useCaptureMode({
    onCapture,
    getTranscriptSince,
    getRecentTranscript,
    getFullTranscript,
  });

  return (
    <CaptureContext.Provider value={captureState}>
      {children}
    </CaptureContext.Provider>
  );
}
```

4. Update the render call in onMount to wrap Overlay with CaptureProvider:
```typescript
onMount: (container) => {
  const root = createRoot(container);
  root.render(
    <CaptureProvider
      onCapture={sendLLMRequest}
      getTranscriptSince={getTranscriptSince}
      getRecentTranscript={getRecentTranscript}
      getFullTranscript={getFullTranscript}
    >
      <Overlay />
    </CaptureProvider>
  );
  return root;
},
```

5. Export useCaptureState for the overlay to consume (for visual indicator).
  </action>
  <verify>
   - `npm run build` passes
   - Content script compiles without errors
   - CaptureProvider wraps Overlay
  </verify>
  <done>Content script integrates capture mode hook with keyboard listeners and LLM request sending</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` passes without errors
2. useCaptureMode hook exports from src/hooks
3. CaptureProvider wraps Overlay in content script
4. Keyboard events trigger sendLLMRequest
5. All transcript helper functions work correctly
</verification>

<success_criteria>
- Hold-to-capture mode: hold hotkey, release to send
- Highlight-to-send mode: select text, press hotkey to send
- Window blur resets hold state (prevents stuck capture)
- LLM_REQUEST sent with question, context, and template ID
- CaptureContext exposes state for visual indicator
</success_criteria>

<output>
After completion, create `.planning/phases/04-llm-integration/04-03-SUMMARY.md`
</output>
