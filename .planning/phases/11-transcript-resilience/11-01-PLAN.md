---
phase: 11-transcript-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/transcription/transcriptBuffer.ts
  - entrypoints/background.ts
autonomous: true

must_haves:
  truths:
    - "Killing the service worker during active transcription and letting it restart preserves all transcript segments captured before termination"
    - "Stopping transcription normally flushes the complete transcript to persistent storage with no missing segments"
    - "Active transcription survives Chrome's 30-second idle timeout without data loss"
  artifacts:
    - path: "src/services/transcription/transcriptBuffer.ts"
      provides: "Debounced write-through transcript buffer with chrome.storage.local persistence"
      exports: ["TranscriptBuffer", "setTranscriptionActive", "wasTranscriptionActive"]
    - path: "entrypoints/background.ts"
      provides: "Integrated transcript buffer replacing bare mergedTranscript array"
      contains: "transcriptBuffer"
  key_links:
    - from: "src/services/transcription/transcriptBuffer.ts"
      to: "chrome.storage.local"
      via: "debounced set/get with 2-second window"
      pattern: "chrome\\.storage\\.local\\.(set|get|remove)"
    - from: "entrypoints/background.ts"
      to: "src/services/transcription/transcriptBuffer.ts"
      via: "import and instantiation"
      pattern: "transcriptBuffer\\.(add|flush|clear|load|getEntries)"
    - from: "entrypoints/background.ts"
      to: "startKeepAlive/stopKeepAlive"
      via: "called on START/STOP_TRANSCRIPTION"
      pattern: "startKeepAlive\\(\\)"
---

<objective>
Create a persistent transcript buffer that survives service worker termination and integrate it into the background script, replacing the volatile in-memory mergedTranscript array.

Purpose: During interviews, Chrome can terminate the service worker at any time (30-second idle timeout, low memory, forced kill). Without persistence, the entire transcript is lost. This phase makes transcript data resilient by writing it to chrome.storage.local with debounced saves and rehydrating on service worker restart.

Output: TranscriptBuffer class + fully wired background.ts with keep-alive during transcription and session recovery on restart.
</objective>

<execution_context>
@/Users/sasha-marchuk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sasha-marchuk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-transcript-resilience/11-RESEARCH.md
@entrypoints/background.ts
@src/types/transcript.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TranscriptBuffer service with debounced persistence</name>
  <files>src/services/transcription/transcriptBuffer.ts</files>
  <action>
Create `src/services/transcription/transcriptBuffer.ts` with:

1. **TranscriptBuffer class** with these members:
   - `private entries: TranscriptEntry[]` -- in-memory buffer
   - `private dirty: boolean` -- tracks unsaved changes
   - `private saveTimer: ReturnType<typeof setTimeout> | null` -- debounce timer
   - `private loaded: boolean` -- whether load() has been called
   - Constants: `STORAGE_KEY = '_transcript_buffer'`, `DEBOUNCE_MS = 2000`

2. **Methods:**
   - `async load(): Promise<void>` -- reads from `chrome.storage.local.get(STORAGE_KEY)`, validates array, sets `loaded = true`. Logs entry count. On error, starts fresh with empty array.
   - `add(entry: TranscriptEntry): void` -- inserts entry in chronological order by timestamp (same insertion logic as current `addTranscriptEntry` in background.ts: iterate backwards to find correct position, splice). Sets `dirty = true`, calls `scheduleSave()`.
   - `getEntries(): TranscriptEntry[]` -- returns entries array (for broadcast).
   - `private scheduleSave(): void` -- clears existing timer, sets new `setTimeout(() => this.flush(), DEBOUNCE_MS)`.
   - `async flush(): Promise<void>` -- if not dirty, return early. Clears timer. Writes entries to `chrome.storage.local.set({ [STORAGE_KEY]: this.entries })`. Sets `dirty = false`. Logs errors, does not throw.
   - `async clear(): Promise<void>` -- resets entries to [], dirty to false, clears timer, removes key from storage via `chrome.storage.local.remove(STORAGE_KEY)`.
   - `get length(): number` -- returns entries.length.
   - `get isLoaded(): boolean` -- returns loaded flag.

3. **Exported helper functions:**
   - `setTranscriptionActive(active: boolean): Promise<void>` -- sets/removes `_transcription_active` flag in chrome.storage.local.
   - `wasTranscriptionActive(): Promise<boolean>` -- reads `_transcription_active` flag, returns boolean.

4. **Import:** Use relative import for TranscriptEntry type: `import type { TranscriptEntry } from '../../types/transcript'` (NOT @/ alias -- WXT build constraint from Phase 10 decision).

Reference the complete implementation in 11-RESEARCH.md "Code Examples" section. Follow it closely.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors in the new file. Verify the file exports TranscriptBuffer, setTranscriptionActive, wasTranscriptionActive.
  </verify>
  <done>
TranscriptBuffer class exists with load/add/flush/clear/getEntries methods, debounced persistence to chrome.storage.local, and helper functions for the active transcription flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TranscriptBuffer into background.ts with keep-alive and recovery</name>
  <files>entrypoints/background.ts</files>
  <action>
Modify `entrypoints/background.ts` with these specific changes:

1. **Replace mergedTranscript with TranscriptBuffer:**
   - Add import: `import { TranscriptBuffer, setTranscriptionActive, wasTranscriptionActive } from '../src/services/transcription/transcriptBuffer';`
   - Replace `let mergedTranscript: TranscriptEntry[] = [];` (line 21) with `const transcriptBuffer = new TranscriptBuffer();`
   - Keep `interimEntries` Map as-is (interim data is ephemeral by nature).

2. **Update init chain** (the `encryptionService.initialize()` promise chain starting at line 127):
   - After `storeReadyPromise` resolves, BEFORE setting `storeReady = true`, add recovery logic:
     ```typescript
     .then(async () => {
       // Check if recovering from SW termination during active transcription
       const wasActive = await wasTranscriptionActive();
       if (wasActive) {
         await transcriptBuffer.load();
         isTranscriptionActive = true;
         startKeepAlive();
         console.log('TranscriptBuffer: Recovered', transcriptBuffer.length, 'entries after SW restart');
       }
       storeReady = true;
       // ... drain queue (existing code) ...
     })
     ```

3. **Update broadcastTranscript()** (line 77-97):
   - Replace `mergedTranscript` reference on line 95 with `transcriptBuffer.getEntries()`:
     ```typescript
     entries: [...transcriptBuffer.getEntries(), ...interimAsEntries],
     ```

4. **Update addTranscriptEntry()** (line 103-121):
   - Remove the manual insertion logic (lines 104-117 that do the splice into `mergedTranscript`).
   - Replace with: `transcriptBuffer.add(entry);`
   - Keep the `broadcastTranscript()` call.
   - The function becomes:
     ```typescript
     async function addTranscriptEntry(entry: TranscriptEntry): Promise<void> {
       transcriptBuffer.add(entry);
       await broadcastTranscript();
     }
     ```

5. **Update START_TRANSCRIPTION handler** (line 744):
   - Replace `mergedTranscript = [];` with `await transcriptBuffer.clear();`
   - Add `await setTranscriptionActive(true);` after clearing
   - Add `startKeepAlive();` after setting `isTranscriptionActive = true`
   - Final order in handler (after ensureOffscreenDocument and API key check):
     ```typescript
     await transcriptBuffer.clear();
     interimEntries.clear();
     await setTranscriptionActive(true);
     // ... forward to offscreen (existing) ...
     isTranscriptionActive = true;
     startKeepAlive();
     ```

6. **Update STOP_TRANSCRIPTION handler** (line 780):
   - Add `await transcriptBuffer.flush();` before setting `isTranscriptionActive = false`
   - Add `await setTranscriptionActive(false);` after
   - Add keep-alive stop (only if no active LLM requests):
     ```typescript
     await transcriptBuffer.flush();
     // ... forward to offscreen (existing) ...
     isTranscriptionActive = false;
     await setTranscriptionActive(false);
     if (activeAbortControllers.size === 0) {
       stopKeepAlive();
     }
     ```

7. **Remove stale import:** The `TranscriptEntry` import from `'../src/types/transcript'` (line 18) may still be needed for the TRANSCRIPT_FINAL handler where the entry object is created inline. Keep it if used, remove if not.

**Key constraints:**
- Use relative imports (not @/ alias) for the transcriptBuffer import -- WXT build constraint.
- Do NOT encrypt transcript data -- write directly to chrome.storage.local, not through Zustand store/encryption adapter.
- Do NOT persist interimEntries -- they are ephemeral by nature.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no type errors. Run `npm run build` (or `npx wxt build`) -- extension builds successfully. Verify `mergedTranscript` variable no longer exists in background.ts (search for it). Verify `transcriptBuffer` is used in broadcastTranscript, addTranscriptEntry, START_TRANSCRIPTION, and STOP_TRANSCRIPTION handlers.
  </verify>
  <done>
background.ts uses TranscriptBuffer instead of bare array. Keep-alive starts on START_TRANSCRIPTION and stops on STOP_TRANSCRIPTION (when no LLM requests active). Service worker restart during active transcription recovers buffer from storage. Flush happens on STOP_TRANSCRIPTION before clearing the active flag.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` (or `npx wxt build`) succeeds
3. `grep -r "mergedTranscript" entrypoints/background.ts` returns zero results
4. `grep "transcriptBuffer" entrypoints/background.ts` shows usage in broadcastTranscript, addTranscriptEntry, START_TRANSCRIPTION, STOP_TRANSCRIPTION, and init chain
5. `grep "startKeepAlive" entrypoints/background.ts` shows calls in START_TRANSCRIPTION handler and recovery block (in addition to existing LLM usage)
6. `grep "_transcription_active" src/services/transcription/transcriptBuffer.ts` shows the flag key
</verification>

<success_criteria>
- TranscriptBuffer class persists entries to chrome.storage.local with 2-second debounce
- background.ts uses TranscriptBuffer instead of in-memory array
- Service worker keep-alive is active during transcription (prevents 30-second idle kill)
- On SW restart during active transcription, buffer is loaded from storage and transcription state is restored
- STOP_TRANSCRIPTION flushes buffer and clears active flag
- START_TRANSCRIPTION clears buffer for new session
- Extension builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-transcript-resilience/11-01-SUMMARY.md`
</output>
