{
  "meta": {
    "rule_sync": true,
    "rule_locations": ["CLAUDE.md", ".planning/config.json"],
    "notes": "All new rules must be recorded in BOTH CLAUDE.md and this config. Never add a rule to only one location."
  },
  "mode": "yolo",
  "depth": "comprehensive",
  "parallelization": true,
  "parallel_phases": {
    "enabled": true,
    "method": "separate_terminals",
    "best_practices": {
      "branch_from_same_base": true,
      "file_ownership": "Each parallel phase must own distinct files. Shared files assigned to ONE phase only.",
      "integration_branch": "After parallel phases complete, merge one-by-one into milestone/vX.Y-phase-A-B-C branch.",
      "conflict_resolution": "File owner phase takes priority. Shared files merged manually.",
      "test_after_merge": "Run tsc --noEmit and eslint after each merge.",
      "polish_on_integration": "Polish runs on the final integrated branch, not individual phase branches."
    },
    "branch_naming": {
      "feature": "feature/phase-{N}-{short-name}",
      "integration": "milestone/v{X.Y}-phase-{A}-{B}-{C}"
    },
    "base_branch_algorithm": {
      "rule": "NEVER branch from main mid-milestone. Always branch from latest milestone/* integration branch.",
      "steps": [
        "1. Read STATE.md to find current position",
        "2. Find latest milestone/* branch for current milestone version",
        "3. If no milestone branch exists, base is main",
        "4. If parallel phases done but not integrated — integrate first, then start new phase"
      ]
    },
    "pre_phase_checklist": [
      "git branch --sort=-committerdate — find latest milestone branch",
      "cat .planning/STATE.md — confirm current position",
      "Verify base branch contains all prerequisite phases",
      "Create feature branch from correct base",
      "If parallel phases not yet integrated — integrate first"
    ],
    "notes": "User prefers running independent phases in parallel via separate Claude Code terminals on separate branches. Only parallelize phases with no shared file dependencies. After parallel phases, a dedicated integration step merges all branches into a new milestone branch before continuing."
  },
  "commit_docs": true,
  "model_profile": "quality",
  "workflow": {
    "research": true,
    "plan_check": true,
    "verifier": true
  },
  "git": {
    "branch_per_phase": true,
    "branch_pattern": "feature/phase-{phase_number}-{phase_name}",
    "auto_pr": true,
    "pr_target": "main",
    "direct_merge_to_main": false,
    "never_delete_branches": true,
    "merge_strategy": "squash",
    "notes": "NEVER merge directly to main. Always create PR. User reviews and merges manually. NEVER delete branches - preserve for history. Use squash merge to keep main clean."
  },
  "polish": {
    "sequential_only": true,
    "steps": ["performance", "type-safety", "simplification", "cleanup", "code-review", "fixes", "milestone-pr"],
    "branch_pattern": "polish/{milestone}-optimization",
    "milestone_pr": {
      "enabled": true,
      "title_pattern": "feat: Milestone vX.Y - {milestone_name}",
      "includes": "All phase changes + polish commits in single consolidated PR to main"
    },
    "notes": "Run /polish-milestone after each milestone. Steps must run sequentially to avoid conflicts. Final step creates consolidated milestone PR to main.",
    "post_phase_testing": {
      "required": true,
      "when": ["after each phase completion", "after polish completion"],
      "must_include": ["build command", "phase-specific test steps", "expected behavior"],
      "notes": "Claude MUST send manual testing instructions after every phase and after polishing. Never skip."
    }
  },
  "todos": {
    "support_raw_prompts": true,
    "storage_path": ".planning/todos/",
    "states": ["pending", "done"],
    "areas": ["feature", "bug", "refactor", "docs", "test", "ui", "api", "config"],
    "auto_detection": true,
    "workflow": {
      "add": "Detect feature/bug requests in plain language → call /gsd:add-todo → create structured markdown",
      "list": "Raw prompt 'show todos' or /gsd:check-todos → list with areas/age → allow selection",
      "work": "Raw prompt 'start working on X' → find matching todo → move to done/ → load context → begin implementation"
    },
    "notes": "Support both CLI commands and raw prompts. Future-proof by following GSD pattern: capture → store → route to action."
  }
}
